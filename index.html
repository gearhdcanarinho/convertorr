<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modder's GLB to OBJ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #030712; color: #D1D5DB; user-select: none; }
        #canvas-container { width: 100%; height: 100%; display: block; outline: none; }
        
        /* Custom Scrollbar */
        .custom-scrollbar::-webkit-scrollbar { width: 6px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: #111827; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #374151; border-radius: 3px; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #4B5563; }
        
        /* Cursors */
        .cursor-select { cursor: crosshair !important; }
        .cursor-lasso { cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="white" viewBox="0 0 16 16"><path d="M8 1a7 7 0 1 0 0 14A7 7 0 0 0 8 1zm0 1.5a5.5 5.5 0 1 1 0 11 5.5 5.5 0 0 1 0-11z"/></svg>') 8 8, crosshair !important; }
        .cursor-wand { cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="white" viewBox="0 0 16 16"><path d="M8.5 1.5a.5.5 0 0 1 1 0v2.293l1.146-1.147a.5.5 0 0 1 .708.708L10.207 4.5h2.293a.5.5 0 0 1 0 1h-2.293l1.147 1.146a.5.5 0 0 1-.708.708L9.5 6.207V8.5a.5.5 0 0 1-1 0V6.207L7.354 7.354a.5.5 0 1 1-.708-.708L7.793 5.5H5.5a.5.5 0 0 1 0-1h2.293L6.646 3.354a.5.5 0 1 1 .708-.708L8.5 3.793V1.5zM2.146 14.854a.5.5 0 0 1-.708-.708l11-11a.5.5 0 0 1 .708.708l-11 11z"/></svg>') 0 16, crosshair !important; }
        
        /* Hierarchy Tree Styles */
        .tree-item { display: flex; align-items: center; justify-content: space-between; padding: 4px 6px; border-radius: 4px; margin-bottom: 2px; border: 1px solid transparent; background: #111827; }
        .tree-item:hover { background-color: #1F2937; }
        .tree-item.selected { background-color: #1E3A8A; border-color: #2563EB; }
        .tree-item-name { cursor: pointer; flex-grow: 1; font-size: 11px; color: #D1D5DB; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; padding-right: 8px;}
        .tree-item-name:hover { color: #60A5FA; }
        .visibility-toggle { cursor: pointer; color: #9CA3AF; padding: 2px; }
        .visibility-toggle:hover { color: #F3F4F6; }
        .visibility-hidden { color: #4B5563; }
        
        /* Toolbar buttons */
        .tool-btn { @apply w-10 h-10 flex items-center justify-center rounded-lg bg-gray-900 text-gray-400 hover:bg-gray-800 hover:text-white transition-all border border-gray-800; }
        .tool-btn.active { @apply bg-blue-600 text-white border-blue-500 shadow-[0_0_10px_rgba(37,99,235,0.4)]; }
        
        /* Canvas for Lasso */
        #lasso-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 20; }
    </style>
    <!-- Import Maps for Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body class="flex h-screen font-sans text-xs">

    <!-- LEFT PANEL: Tool Shelf (Blender Style) -->
    <div class="w-16 bg-gray-950 border-r border-gray-800 flex flex-col items-center py-4 gap-3 z-10 shadow-xl">
        
        <div class="text-[9px] text-gray-500 font-bold mb-1 tracking-widest">TOOLS</div>
        
        <button id="tool-select" class="tool-btn active" title="Select (V)">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 15l-2 5L9 9l11 4-5 2zm0 0l5 5M7.188 2.239l.777 2.897M5.136 7.965l-2.898-.777M13.95 4.05l-2.122 2.122m-5.657 5.656l-2.12 2.122"></path></svg>
        </button>
        <button id="tool-box" class="tool-btn" title="Box / Marquee (M)">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4h4v4H4zM16 4h4v4h-4zM4 16h4v4H4zM16 16h4v4h-4zM8 6h8M8 18h8M6 8v8M18 8v8"></path></svg>
        </button>
        <button id="tool-lasso" class="tool-btn" title="Lasso Select (L)">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A4 4 0 002 9v11a2 2 0 002 2h10a2 2 0 002-2v-5.655l-1.248-.832zM16 3a3 3 0 11-6 0 3 3 0 016 0z"></path></svg>
        </button>
        <button id="tool-wand" class="tool-btn" title="Magic Wand / Linked Faces (W)">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19.428 15.428a2 2 0 00-1.022-.547l-2.387-.477a6 6 0 00-3.86.517l-.318.158a6 6 0 01-3.86.517L6.05 15.21a2 2 0 00-1.806.547M8 4h8l-1 1v5.172a2 2 0 00.586 1.414l5 5c1.26 1.26.367 3.414-1.415 3.414H4.828c-1.782 0-2.674-2.154-1.414-3.414l5-5A2 2 0 009 10.172V5L8 4z"></path></svg>
        </button>

        <div class="w-8 h-px bg-gray-800 my-2"></div>
        <div class="text-[9px] text-gray-500 font-bold mb-1 tracking-widest">GIZMO</div>

        <button id="gizmo-translate" class="tool-btn active" title="Move">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4"></path></svg>
        </button>
        <button id="gizmo-rotate" class="tool-btn" title="Rotate">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg>
        </button>
        <button id="gizmo-scale" class="tool-btn" title="Scale">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4"></path></svg>
        </button>

    </div>

    <!-- CENTER PANEL: 3D Viewport -->
    <div class="flex-grow relative bg-gray-950 flex flex-col">
        <!-- Top Toolbar over Viewport -->
        <div class="absolute top-0 left-0 w-full p-3 pointer-events-none flex justify-between z-10">
            <div class="flex gap-2 pointer-events-auto">
                <label for="file-upload" class="bg-blue-600 hover:bg-blue-500 text-white px-4 py-1.5 rounded shadow cursor-pointer font-bold flex items-center gap-2">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path></svg>
                    Import GLB
                </label>
                <input id="file-upload" type="file" class="hidden" accept=".glb" />
                
                <button id="btn-undo" class="bg-gray-800 border border-gray-700 hover:bg-gray-700 text-white px-3 py-1.5 rounded shadow opacity-50 cursor-not-allowed transition-all" title="Undo (Ctrl+Z)">
                    Undo
                </button>
                <button id="btn-wireframe" class="bg-gray-800 border border-gray-700 hover:bg-gray-700 text-white px-3 py-1.5 rounded shadow transition-all">
                    Wireframe
                </button>
                
                <!-- Background Color Picker -->
                <div class="flex items-center gap-2 bg-gray-800 border border-gray-700 px-2 py-1.5 rounded shadow">
                    <span class="text-[10px] text-gray-400">BG:</span>
                    <input type="color" id="bg-color" value="#111827" class="w-5 h-5 rounded cursor-pointer border-0 bg-transparent p-0">
                </div>
            </div>

            <!-- Viewport Legends -->
            <div class="bg-gray-900/80 border border-gray-800 p-2 rounded backdrop-blur-sm pointer-events-auto text-[10px]">
                <div class="grid grid-cols-2 gap-x-4 gap-y-1 text-gray-400">
                    <p><span class="text-blue-400 font-bold">NUM 1</span> Front</p>
                    <p><span class="text-blue-400 font-bold">NUM 3</span> Right</p>
                    <p><span class="text-blue-400 font-bold">NUM 7</span> Top</p>
                    <p><span class="text-blue-400 font-bold">NUM 9</span> Bottom</p>
                </div>
            </div>
        </div>

        <canvas id="lasso-canvas"></canvas>
        <div id="selection-box" class="hidden absolute border border-blue-500 bg-blue-500/20 pointer-events-none z-30"></div>
        <div id="canvas-container" tabindex="0" class="flex-grow w-full h-full outline-none"></div>

        <!-- Loading Overlay -->
        <div id="loading-overlay" class="absolute inset-0 z-40 bg-gray-950/90 flex items-center justify-center hidden backdrop-blur-sm">
            <div class="flex flex-col items-center">
                <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500 mb-4"></div>
                <p id="loading-text" class="text-blue-400 font-bold tracking-widest uppercase">PROCESSING...</p>
            </div>
        </div>
    </div>

    <!-- RIGHT PANEL: Outliner & Properties -->
    <div class="w-80 bg-gray-950 border-l border-gray-800 flex flex-col z-10 shadow-xl overflow-y-auto custom-scrollbar">
        
        <!-- Outliner / Hierarchy -->
        <div class="p-4 border-b border-gray-800 flex-grow max-h-[50vh] flex flex-col">
            <div class="flex justify-between items-end mb-3">
                <h2 class="text-sm font-bold text-gray-200 flex items-center gap-2">
                    <svg class="w-4 h-4 text-blue-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10"></path></svg>
                    Outliner
                </h2>
                <span id="filename-display" class="text-[10px] text-gray-500 truncate max-w-[120px]">No model</span>
            </div>
            
            <div id="hierarchy-list" class="flex-grow overflow-y-auto custom-scrollbar bg-gray-900 rounded border border-gray-800 p-1 space-y-0.5">
                <div class="text-gray-600 text-center italic py-4">Import a model first</div>
            </div>

            <!-- Modding Actions -->
            <div class="grid grid-cols-2 gap-2 mt-3">
                <button id="btn-action-extract" class="py-1.5 bg-gray-800 hover:bg-gray-700 border border-gray-700 text-gray-300 rounded shadow transition-all">Extract</button>
                <button id="btn-action-duplicate" class="py-1.5 bg-gray-800 hover:bg-gray-700 border border-gray-700 text-gray-300 rounded shadow transition-all">Duplicate</button>
                <button id="btn-obj-mirror" class="py-1.5 bg-gray-800 hover:bg-gray-700 border border-gray-700 text-gray-300 rounded shadow transition-all">Mirror (X)</button>
                <button id="btn-obj-center" class="py-1.5 bg-gray-800 hover:bg-gray-700 border border-gray-700 text-gray-300 rounded shadow transition-all">Center Pivot</button>
            </div>
            <div class="flex gap-2 mt-2">
                <button id="btn-clear-sel" class="flex-1 py-1.5 bg-gray-800 hover:bg-gray-700 border border-gray-700 text-gray-400 rounded">Clear Sel.</button>
                <button id="btn-delete-sel" class="flex-1 py-1.5 bg-red-900/30 hover:bg-red-800/50 border border-red-900/50 text-red-400 rounded">Delete (Del)</button>
            </div>
        </div>

        <!-- Properties / Export -->
        <div class="p-4 border-t border-gray-800 bg-gray-900 flex-grow flex flex-col justify-between">
            
            <div class="space-y-4">
                <h2 class="text-sm font-bold text-gray-200 flex items-center gap-2">
                    <svg class="w-4 h-4 text-emerald-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6V4m0 2a2 2 0 100 4m0-4a2 2 0 110 4m-6 8a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4m6 6v10m6-2a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4"></path></svg>
                    Properties
                </h2>
                
                <!-- Target Profiles -->
                <div>
                    <label class="text-[10px] text-gray-500 uppercase tracking-wider mb-1 block">Export Target Profile</label>
                    <select id="target-type" class="w-full bg-gray-950 border border-gray-800 text-gray-300 text-xs rounded p-2 focus:border-blue-500 focus:outline-none">
                        <option value="full">Target: Full Poly (Original / No Limits)</option>
                        <option value="car">Target: Car Body (Max 32k Verts)</option>
                        <option value="wheel" selected>Target: Wheel (Max 4,240 Polys)</option>
                    </select>
                </div>

                <!-- Stats -->
                <div class="bg-gray-950 rounded border border-gray-800 p-2 text-xs">
                    <p class="flex justify-between items-center mb-1">
                        <span class="text-gray-500">Vertices:</span>
                        <span id="stat-verts" class="font-mono text-gray-300">0</span>
                    </p>
                    <p class="flex justify-between items-center">
                        <span class="text-gray-500">Triangles:</span>
                        <span id="stat-tris" class="font-mono text-gray-300">0</span>
                    </p>
                    <div id="poly-warning" class="hidden mt-2 p-1 bg-red-900/30 border border-red-900/50 text-red-400 text-[9px] text-center rounded">
                        EXCEEDS ENGINE LIMITS
                    </div>
                </div>

                <!-- Manual Decimation (Prevents freezing) -->
                <div id="decimate-block" class="bg-gray-950 rounded border border-gray-800 p-3">
                    <div class="flex justify-between text-[10px] mb-2">
                        <span class="text-gray-400">Target Polys:</span>
                        <span id="target-val" class="text-blue-400 font-mono font-bold">...</span>
                    </div>
                    <input type="range" id="simplify-slider" min="100" max="32768" value="32000" class="w-full accent-blue-500 h-1 mb-3">
                    <button id="btn-apply-decimate" class="w-full py-1.5 bg-blue-600 hover:bg-blue-500 text-white font-bold rounded shadow transition-all disabled:opacity-50 disabled:cursor-not-allowed">
                        Apply Optimization
                    </button>
                    <p class="text-[9px] text-gray-500 mt-2 text-center leading-tight">Decimation is applied manually to prevent browser freezing.</p>
                </div>
            </div>

            <!-- Export -->
            <button id="btn-convert" disabled class="w-full py-3 mt-4 bg-gray-800 text-gray-500 font-bold rounded-lg cursor-not-allowed transition-all border border-gray-700">
                Export LFS .OBJ
            </button>
        </div>
    </div>

    <!-- Main Logic -->
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { SimplifyModifier } from 'three/addons/modifiers/SimplifyModifier.js';
        import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';

        // --- App State ---
        let scene, camera, renderer, controls;
        let modelContainer;
        let currentModel = null;
        let maxModelDimension = 1;
        
        let modelStats = { vertices: 0, triangles: 0 };
        let baseStats = { vertices: 0, triangles: 0 }; 
        let originalFileName = "model";

        const LIMITS = {
            full: { verts: Infinity, polys: Infinity },
            car: { verts: 32768, polys: 65536 },
            wheel: { verts: 32768, polys: 4240 }
        };

        // --- Tool State ---
        let currentTool = 'select'; // 'select', 'box', 'lasso', 'wand'
        let isDragging = false;
        let pointerDownPos = { x: 0, y: 0 };
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let isWireframeActive = false;
        
        // Lasso State
        const lassoCanvas = document.getElementById('lasso-canvas');
        const lassoCtx = lassoCanvas.getContext('2d');
        let lassoPoints = [];
        
        // Marquee State
        let isMarqueeSelecting = false;
        let marqueeStart = new THREE.Vector2();
        let marqueeEnd = new THREE.Vector2();

        // Undo History
        let historyStack = [];
        const MAX_HISTORY = 20;

        // Advanced Gizmo State
        let transformControl, transformProxy;
        let isGizmoDragging = false;
        let currentGizmoMode = 'translate';
        let proxyLocalVertices = new Map();
        let initialProxyMatrixInv = new THREE.Matrix4();

        // Visual Elements
        let hoverMesh, selectionMesh;

        // --- DOM Elements ---
        const container = document.getElementById('canvas-container');
        const selectionBox = document.getElementById('selection-box');
        const fileInput = document.getElementById('file-upload');
        const btnConvert = document.getElementById('btn-convert');
        const loadingOverlay = document.getElementById('loading-overlay');
        const loadingText = document.getElementById('loading-text');
        
        const hierarchyList = document.getElementById('hierarchy-list');
        const btnWireframe = document.getElementById('btn-wireframe');
        const bgColorPicker = document.getElementById('bg-color');
        
        const targetTypeSelect = document.getElementById('target-type');
        const statVerts = document.getElementById('stat-verts');
        const statTris = document.getElementById('stat-tris');
        const vertWarning = document.getElementById('vert-warning');
        const polyWarning = document.getElementById('poly-warning');
        const decimateBlock = document.getElementById('decimate-block');
        
        const btnGizmoTranslate = document.getElementById('gizmo-translate');
        const btnGizmoRotate = document.getElementById('gizmo-rotate');
        const btnGizmoScale = document.getElementById('gizmo-scale');
        
        const toolBtns = {
            select: document.getElementById('tool-select'),
            box: document.getElementById('tool-box'),
            lasso: document.getElementById('tool-lasso'),
            wand: document.getElementById('tool-wand')
        };
        
        const btnActionExtract = document.getElementById('btn-action-extract');
        const btnActionDuplicate = document.getElementById('btn-action-duplicate');
        const btnObjMirror = document.getElementById('btn-obj-mirror');
        const btnObjCenter = document.getElementById('btn-obj-center');

        const btnDeleteSel = document.getElementById('btn-delete-sel');
        const btnClearSel = document.getElementById('btn-clear-sel');
        const btnUndo = document.getElementById('btn-undo');

        const simplifySlider = document.getElementById('simplify-slider');
        const btnApplyDecimate = document.getElementById('btn-apply-decimate');
        const targetVal = document.getElementById('target-val');

        // --- Init Three.js ---
        function initThreeJS() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(bgColorPicker.value);
            
            modelContainer = new THREE.Group();
            scene.add(modelContainer);
            
            const gridHelper = new THREE.GridHelper(10, 10, 0x222222, 0x111111);
            scene.add(gridHelper);

            camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(3, 3, 5);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            container.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // --- Gizmos ---
            transformProxy = new THREE.Object3D();
            scene.add(transformProxy);

            transformControl = new TransformControls(camera, renderer.domElement);
            transformControl.size = 0.7; // Smaller gizmo for precision
            
            transformControl.addEventListener('dragging-changed', function (event) {
                controls.enabled = !event.value;
                isGizmoDragging = event.value;

                if (event.value) {
                    saveHistoryState();
                    initialProxyMatrixInv.copy(transformProxy.matrixWorld).invert();
                    proxyLocalVertices.clear();
                    
                    currentModel.traverse((child) => {
                        if (child.isMesh && child.userData.selectedFaces && child.userData.selectedFaces.size > 0 && !child.userData.isHidden) {
                            const index = child.userData.originalGeometry.index;
                            const pos = child.userData.originalGeometry.attributes.position;
                            child.userData.selectedFaces.forEach(faceIdx => {
                                const a = index.getX(faceIdx * 3), b = index.getX(faceIdx * 3 + 1), c = index.getX(faceIdx * 3 + 2);
                                [a, b, c].forEach(idx => {
                                    const key = child.uuid + '_' + idx;
                                    if (!proxyLocalVertices.has(key)) {
                                        const vLocal = new THREE.Vector3().fromBufferAttribute(pos, idx);
                                        const vWorld = vLocal.applyMatrix4(child.matrixWorld);
                                        const vProxy = vWorld.applyMatrix4(initialProxyMatrixInv);
                                        proxyLocalVertices.set(key, vProxy);
                                    }
                                });
                            });
                        }
                    });
                } else {
                    recalculateBaseStats();
                }
            });

            transformControl.addEventListener('change', () => {
                if (!isGizmoDragging) return;
                
                currentModel.traverse((child) => {
                    if (child.isMesh && child.userData.selectedFaces && child.userData.selectedFaces.size > 0 && !child.userData.isHidden) {
                        const pos = child.userData.originalGeometry.attributes.position;
                        const invMeshWorld = child.matrixWorld.clone().invert();
                        
                        child.userData.selectedFaces.forEach(faceIdx => {
                            const index = child.userData.originalGeometry.index;
                            const a = index.getX(faceIdx * 3), b = index.getX(faceIdx * 3 + 1), c = index.getX(faceIdx * 3 + 2);
                            
                            [a, b, c].forEach(idx => {
                                const key = child.uuid + '_' + idx;
                                const vProxyLocal = proxyLocalVertices.get(key);
                                if (vProxyLocal) {
                                    const newWorldV = vProxyLocal.clone().applyMatrix4(transformProxy.matrixWorld);
                                    const newLocalV = newWorldV.applyMatrix4(invMeshWorld);
                                    pos.setXYZ(idx, newLocalV.x, newLocalV.y, newLocalV.z);
                                }
                            });
                        });
                        
                        pos.needsUpdate = true;
                        if (child.geometry.attributes.position) {
                            child.geometry.attributes.position.array.set(pos.array);
                            child.geometry.attributes.position.needsUpdate = true;
                            child.geometry.computeVertexNormals();
                        }
                    }
                });
                updateSelectionVisuals();
            });
            scene.add(transformControl);

            // Visual Helpers
            hoverMesh = new THREE.Mesh(new THREE.BufferGeometry(), new THREE.MeshBasicMaterial({ color: 0xffff00, side: THREE.DoubleSide, transparent: true, opacity: 0.5, depthTest: false }));
            hoverMesh.visible = false;
            scene.add(hoverMesh);

            selectionMesh = new THREE.Mesh(new THREE.BufferGeometry(), new THREE.MeshBasicMaterial({ color: 0x2563EB, side: THREE.DoubleSide, transparent: true, opacity: 0.6, depthTest: false }));
            selectionMesh.visible = false;
            scene.add(selectionMesh);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 2);
            dirLight.position.set(5, 10, 7.5);
            scene.add(dirLight);
            const fillLight = new THREE.DirectionalLight(0xffffff, 1);
            fillLight.position.set(-5, 0, -5);
            scene.add(fillLight);

            window.addEventListener('resize', onWindowResize, false);
            setupMouseEvents();
            setupCameraHotkeys();
            animate();
            
            // Set initial cursor
            updateCursor();
        }

        function onWindowResize() {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
            
            // Sync Lasso Canvas
            lassoCanvas.width = container.clientWidth;
            lassoCanvas.height = container.clientHeight;
        }

        function animate() {
            requestAnimationFrame(animate);
            if(controls.enabled) controls.update();
            renderer.render(scene, camera);
        }
        
        // Background Color
        bgColorPicker.addEventListener('input', (e) => {
            scene.background = new THREE.Color(e.target.value);
        });

        // --- Upload Logic ---
        fileInput.addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (!file) return;

            originalFileName = file.name.replace(/\.[^/.]+$/, "");
            document.getElementById('filename-display').textContent = file.name;
            showLoading(true, "LOADING GLB...");

            const reader = new FileReader();
            reader.onload = function(e) { loadGLTF(e.target.result); };
            reader.readAsArrayBuffer(file);
        });

        function loadGLTF(arrayBuffer) {
            const loader = new GLTFLoader();
            
            if (currentModel) {
                modelContainer.remove(currentModel);
                disableGizmo();
                currentModel.traverse((child) => {
                    if (child.isMesh) {
                        child.geometry.dispose();
                        if(Array.isArray(child.material)) child.material.forEach(m => m.dispose());
                        else if(child.material) child.material.dispose();
                    }
                });
            }

            loader.parse(arrayBuffer, '', (gltf) => {
                currentModel = gltf.scene;
                
                currentModel.traverse((child) => {
                    if (child.isMesh) {
                        if (child.material) {
                            child.material.side = THREE.DoubleSide;
                            child.material.wireframe = isWireframeActive;
                        }
                        
                        try {
                            // Slightly higher tolerance to avoid creating micro-holes on sub-par models
                            let merged = BufferGeometryUtils.mergeVertices(child.geometry, 1e-4); 
                            merged.computeVertexNormals();
                            child.geometry = merged;
                        } catch(e) { console.warn("Error welding model vertices.", e); }
                        
                        child.userData.originalGeometry = child.geometry.clone();
                        child.userData.deletedFaces = new Set();
                        child.userData.selectedFaces = new Set();
                        child.userData.isHidden = false;
                        
                        // Build Adjacency List for Magic Wand (Linked Selection)
                        buildAdjacencyList(child);
                    }
                });

                modelContainer.rotation.set(0, 0, 0);

                const box = new THREE.Box3().setFromObject(currentModel);
                const size = box.getSize(new THREE.Vector3());
                maxModelDimension = Math.max(size.x, size.y, size.z);
                const scale = 4 / maxModelDimension;
                currentModel.scale.set(scale, scale, scale);
                
                const boxScaled = new THREE.Box3().setFromObject(currentModel);
                const centerScaled = boxScaled.getCenter(new THREE.Vector3());
                currentModel.position.set(-centerScaled.x, -boxScaled.min.y, -centerScaled.z);

                modelContainer.add(currentModel);
                resetCamera();

                buildHierarchyTree();
                updateTargetUI();
                recalculateBaseStats();
                clearHistory();
                
                btnConvert.disabled = false;
                btnConvert.classList.remove('bg-gray-800', 'text-gray-500', 'cursor-not-allowed');
                btnConvert.classList.add('bg-blue-600', 'text-white', 'hover:bg-blue-500', 'border-blue-500');

                showLoading(false);
            }, () => { alert("Error loading GLB file."); showLoading(false); });
        }
        
        function buildAdjacencyList(mesh) {
            const index = mesh.userData.originalGeometry.index;
            const adjacency = new Map();
            for(let i=0; i<index.count; i+=3) {
                const faceIdx = i/3;
                [index.getX(i), index.getX(i+1), index.getX(i+2)].forEach(v => {
                    if(!adjacency.has(v)) adjacency.set(v, []);
                    adjacency.get(v).push(faceIdx);
                });
            }
            mesh.userData.adjacency = adjacency;
        }

        // --- Hierarchy Tree Logic ---
        function buildHierarchyTree() {
            hierarchyList.innerHTML = '';
            
            const eyeOpen = `<svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path></svg>`;
            const eyeClosed = `<svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.88 9.88l-3.29-3.29m7.532 7.532l3.29 3.29M3 3l3.59 3.59m0 0A9.953 9.953 0 0112 5c4.478 0 8.268 2.943 9.543 7a10.025 10.025 0 01-4.132 5.411m0 0L21 21"></path></svg>`;

            let partCount = 0;

            currentModel.traverse((child) => {
                if (child.isMesh) {
                    partCount++;
                    const name = child.name || `Object_${partCount}`;
                    
                    const div = document.createElement('div');
                    div.className = 'tree-item';
                    
                    if (child.userData.selectedFaces && child.userData.selectedFaces.size > 0) {
                        div.classList.add('selected');
                    }
                    
                    const nameSpan = document.createElement('span');
                    nameSpan.className = 'tree-item-name';
                    nameSpan.textContent = name;
                    
                    nameSpan.addEventListener('click', (e) => {
                        saveHistoryState();
                        if (!e.shiftKey) {
                            currentModel.traverse(c => { if(c.isMesh) c.userData.selectedFaces.clear(); });
                        }
                        const indexCount = child.userData.originalGeometry.index.count;
                        for(let i = 0; i < indexCount; i+=3) {
                            const faceIdx = i / 3;
                            if (!child.userData.deletedFaces.has(faceIdx)) child.userData.selectedFaces.add(faceIdx);
                        }
                        updateSelectionVisuals();
                        buildHierarchyTree();
                        activateGizmoIfNeeded();
                    });

                    const visSpan = document.createElement('span');
                    visSpan.className = 'visibility-toggle';
                    visSpan.innerHTML = child.userData.isHidden ? eyeClosed : eyeOpen;
                    if (child.userData.isHidden) visSpan.classList.add('visibility-hidden');
                    
                    visSpan.addEventListener('click', () => {
                        child.userData.isHidden = !child.userData.isHidden;
                        child.visible = !child.userData.isHidden;
                        
                        visSpan.innerHTML = child.userData.isHidden ? eyeClosed : eyeOpen;
                        if (child.userData.isHidden) visSpan.classList.add('visibility-hidden');
                        else visSpan.classList.remove('visibility-hidden');
                        
                        recalculateBaseStats();
                        updateLiveStats();
                    });

                    div.appendChild(nameSpan);
                    div.appendChild(visSpan);
                    hierarchyList.appendChild(div);
                }
            });
        }

        // --- Tools Logic (V, M, L, W) ---
        function setTool(toolName) {
            currentTool = toolName;
            Object.values(toolBtns).forEach(btn => btn.classList.remove('active'));
            toolBtns[toolName].classList.add('active');
            updateCursor();
            controls.enabled = (toolName === 'select' || toolName === 'wand');
        }
        
        function updateCursor() {
            container.className = 'flex-grow w-full h-full outline-none';
            if(currentTool === 'lasso') container.classList.add('cursor-lasso');
            else if(currentTool === 'wand') container.classList.add('cursor-wand');
            else container.classList.add('cursor-select');
        }

        Object.keys(toolBtns).forEach(key => {
            toolBtns[key].addEventListener('click', () => setTool(key));
        });

        // Keyboard Shortcuts
        window.addEventListener('keydown', (e) => {
            if (document.activeElement.tagName === 'INPUT') return;
            const key = e.key.toLowerCase();
            if (key === 'v') setTool('select');
            if (key === 'm') setTool('box');
            if (key === 'l') setTool('lasso');
            if (key === 'w') setTool('wand');
            if (key === 'g') setGizmoMode('translate');
            if (key === 'r') setGizmoMode('rotate');
            if (key === 's') setGizmoMode('scale');
        });

        // --- Modding Tools (Object Level) ---
        btnObjMirror.addEventListener('click', () => {
            if(!currentModel) return;
            saveHistoryState();
            let mirroredAny = false;
            const newMeshesToAttach = [];

            currentModel.traverse((child) => {
                if (child.isMesh && child.userData.selectedFaces && child.userData.selectedFaces.size > 0 && !child.userData.isHidden) {
                    const newGeom = child.userData.originalGeometry.clone();
                    const pos = newGeom.attributes.position;
                    for (let i = 0; i < pos.count; i++) pos.setX(i, -pos.getX(i));
                    
                    const index = newGeom.index;
                    for (let i = 0; i < index.count; i += 3) {
                        const a = index.getX(i);
                        index.setX(i, index.getX(i + 2));
                        index.setX(i + 2, a);
                    }
                    newGeom.computeVertexNormals();

                    const newMesh = new THREE.Mesh(newGeom, child.material);
                    newMesh.name = (child.name || "Part") + "_Mirrored";
                    newMesh.position.set(-child.position.x, child.position.y, child.position.z);
                    
                    const euler = new THREE.Euler().setFromQuaternion(child.quaternion);
                    euler.y = -euler.y; euler.z = -euler.z;
                    newMesh.quaternion.setFromEuler(euler);
                    newMesh.scale.copy(child.scale);

                    newMesh.userData.originalGeometry = newGeom;
                    newMesh.userData.deletedFaces = new Set(child.userData.deletedFaces);
                    newMesh.userData.selectedFaces = new Set();
                    newMesh.userData.isHidden = false;
                    buildAdjacencyList(newMesh);

                    newMeshesToAttach.push({parent: child.parent, mesh: newMesh});
                    mirroredAny = true;
                }
            });

            if(mirroredAny) {
                newMeshesToAttach.forEach(item => item.parent.add(item.mesh));
                disableGizmo();
                resetGeometryForErasing();
                recalculateBaseStats();
                buildHierarchyTree();
            } else {
                historyStack.pop();
            }
        });

        btnObjCenter.addEventListener('click', () => {
            if(!currentModel) return;
            saveHistoryState();
            let centeredAny = false;

            currentModel.traverse((child) => {
                if (child.isMesh && child.userData.selectedFaces && child.userData.selectedFaces.size > 0 && !child.userData.isHidden) {
                    const geom = child.userData.originalGeometry;
                    geom.computeBoundingBox();
                    const center = new THREE.Vector3();
                    geom.boundingBox.getCenter(center);

                    geom.translate(-center.x, -center.y, -center.z);
                    child.position.add(center.applyQuaternion(child.quaternion).multiply(child.scale));
                    child.updateMatrixWorld(true);

                    if (child.geometry.attributes.position) {
                        child.geometry.attributes.position.array.set(geom.attributes.position.array);
                        child.geometry.attributes.position.needsUpdate = true;
                    }
                    centeredAny = true;
                }
            });

            if (centeredAny) {
                disableGizmo();
                updateSelectionVisuals();
                activateGizmoIfNeeded();
            } else {
                historyStack.pop();
            }
        });

        // --- Wireframe & Camera ---
        btnWireframe.addEventListener('click', () => {
            isWireframeActive = !isWireframeActive;
            btnWireframe.classList.toggle('text-blue-400', isWireframeActive);
            btnWireframe.classList.toggle('text-white', !isWireframeActive);
            if (currentModel) {
                currentModel.traverse(c => {
                    if (c.isMesh && c.material) c.material.wireframe = isWireframeActive;
                });
            }
        });

        function resetCamera() {
            camera.position.set(4, 3, 5);
            controls.target.set(0, 2, 0);
            controls.update();
        }

        function setupCameraHotkeys() {
            window.addEventListener('keydown', (e) => {
                if (document.activeElement.tagName === 'INPUT') return;
                if (!currentModel) return;

                const dist = 5; 
                const target = new THREE.Vector3(0, 2, 0);

                switch(e.code) {
                    case 'Numpad7': case 'Digit7': camera.position.set(0, dist + 2, 0); break; // Top
                    case 'Numpad9': case 'Digit9': camera.position.set(0, -dist + 2, 0); break; // Bottom
                    case 'Numpad1': case 'Digit1': camera.position.set(0, 2, dist); break; // Front
                    case 'Numpad3': case 'Digit3': camera.position.set(dist, 2, 0); break; // Right
                    case 'KeyZ': 
                        if (e.ctrlKey || e.metaKey) {
                            undoLastAction();
                            e.preventDefault();
                        }
                        break;
                    case 'Delete':
                    case 'Backspace':
                        deleteSelectedFaces();
                        e.preventDefault();
                        break;
                    default: return; 
                }
                
                if (['Numpad7','Numpad9','Numpad1','Numpad3','Digit7','Digit9','Digit1','Digit3'].includes(e.code)) {
                    controls.target.copy(target);
                    controls.update();
                }
            });
        }

        // --- Limits & Stats ---
        targetTypeSelect.addEventListener('change', () => {
            if(!currentModel) return;
            updateTargetUI();
            updateLiveStats();
        });

        function updateTargetUI() {
            const target = targetTypeSelect.value;
            const maxPolys = LIMITS[target].polys;
            
            simplifySlider.max = baseStats.triangles;
            
            if (target === 'full') {
                decimateBlock.classList.add('opacity-50', 'pointer-events-none');
                simplifySlider.value = baseStats.triangles;
                targetVal.textContent = "Unlimited";
                btnApplyDecimate.disabled = true;
            } else {
                decimateBlock.classList.remove('opacity-50', 'pointer-events-none');
                const defaultTarget = Math.min(baseStats.triangles, maxPolys);
                simplifySlider.value = defaultTarget;
                targetVal.textContent = defaultTarget.toLocaleString();
                btnApplyDecimate.disabled = false;
            }
        }

        function recalculateBaseStats() {
            baseStats = { vertices: 0, triangles: 0 };
            if(!currentModel) return;
            currentModel.traverse((child) => {
                if (child.isMesh && child.userData.originalGeometry && !child.userData.isHidden) {
                    const idx = child.userData.originalGeometry.index;
                    const deleted = child.userData.deletedFaces;
                    
                    const activeIndices = new Set();
                    let activeFaces = 0;
                    for(let i=0; i<idx.count; i+=3) {
                        const faceIdx = i / 3;
                        if(!deleted.has(faceIdx)) {
                            activeFaces++;
                            activeIndices.add(idx.getX(i));
                            activeIndices.add(idx.getX(i+1));
                            activeIndices.add(idx.getX(i+2));
                        }
                    }
                    baseStats.triangles += activeFaces;
                    baseStats.vertices += activeIndices.size;
                }
            });
            updateTargetUI();
        }

        function updateLiveStats() {
            modelStats = { vertices: 0, triangles: 0 };
            if(!currentModel) return;
            currentModel.traverse((child) => {
                if (child.isMesh && child.geometry.index && !child.userData.isHidden) {
                    modelStats.triangles += child.geometry.index.count / 3;
                    const idx = child.geometry.index;
                    const activeSet = new Set();
                    for(let i=0; i<idx.count; i++) activeSet.add(idx.getX(i));
                    modelStats.vertices += activeSet.size;
                }
            });

            statVerts.textContent = modelStats.vertices.toLocaleString();
            statTris.textContent = Math.floor(modelStats.triangles).toLocaleString();
            
            const target = targetTypeSelect.value;
            if(modelStats.vertices > LIMITS[target].verts) {
                vertWarning.classList.remove('hidden');
                statVerts.classList.add('text-red-400'); statVerts.classList.remove('text-gray-300');
            } else {
                vertWarning.classList.add('hidden');
                statVerts.classList.remove('text-red-400'); statVerts.classList.add('text-gray-300');
            }
            if(modelStats.triangles > LIMITS[target].polys) {
                polyWarning.classList.remove('hidden');
                statTris.classList.add('text-red-400'); statTris.classList.remove('text-gray-300');
            } else {
                polyWarning.classList.add('hidden');
                statTris.classList.remove('text-red-400'); statTris.classList.add('text-gray-300');
            }
        }

        // --- Undo System ---
        function saveHistoryState() {
            if (!currentModel) return;
            const state = [];
            currentModel.traverse((child) => {
                if (child.isMesh && child.userData.originalGeometry) {
                    state.push({
                        uuid: child.uuid,
                        deletedFaces: new Set(child.userData.deletedFaces),
                        selectedFaces: new Set(child.userData.selectedFaces),
                        positions: new Float32Array(child.userData.originalGeometry.attributes.position.array)
                    });
                }
            });
            historyStack.push(state);
            if (historyStack.length > MAX_HISTORY) historyStack.shift();
            updateUndoUI();
        }

        function undoLastAction() {
            if (historyStack.length === 0 || !currentModel) return;
            
            disableGizmo();
            
            const lastState = historyStack.pop();
            const uuidsInState = new Set(lastState.map(s => s.uuid));
            
            const objectsToRemove = [];
            currentModel.traverse((child) => {
                if (child.isMesh && !uuidsInState.has(child.uuid)) objectsToRemove.push(child);
            });
            objectsToRemove.forEach(obj => obj.parent.remove(obj));

            currentModel.traverse((child) => {
                if (child.isMesh && child.userData.originalGeometry) {
                    const savedState = lastState.find(s => s.uuid === child.uuid);
                    if (savedState) {
                        child.userData.deletedFaces = new Set(savedState.deletedFaces);
                        child.userData.selectedFaces = new Set(savedState.selectedFaces);
                        
                        const posAttr = child.userData.originalGeometry.attributes.position;
                        posAttr.array.set(savedState.positions);
                        posAttr.needsUpdate = true;

                        if (child.geometry.attributes.position) {
                            child.geometry.attributes.position.array.set(savedState.positions);
                            child.geometry.attributes.position.needsUpdate = true;
                            child.geometry.computeVertexNormals();
                        }
                    }
                }
            });
            
            buildHierarchyTree(); 
            updateSelectionVisuals();
            resetGeometryForErasing();
            recalculateBaseStats();
            updateUndoUI();
            activateGizmoIfNeeded();
        }

        function clearHistory() {
            historyStack = [];
            updateUndoUI();
        }

        function updateUndoUI() {
            if (historyStack.length > 0) {
                btnUndo.classList.remove('opacity-50', 'cursor-not-allowed');
            } else {
                btnUndo.classList.add('opacity-50', 'cursor-not-allowed');
            }
        }
        
        btnUndo.addEventListener('click', undoLastAction);

        // --- Gizmo Mode ---
        function setGizmoMode(mode) {
            currentGizmoMode = mode;
            transformControl.setMode(mode);
            btnGizmoTranslate.classList.toggle('active-gizmo', mode === 'translate');
            btnGizmoRotate.classList.toggle('active-gizmo', mode === 'rotate');
            btnGizmoScale.classList.toggle('active-gizmo', mode === 'scale');
        }
        btnGizmoTranslate.addEventListener('click', () => setGizmoMode('translate'));
        btnGizmoRotate.addEventListener('click', () => setGizmoMode('rotate'));
        btnGizmoScale.addEventListener('click', () => setGizmoMode('scale'));

        function activateGizmoIfNeeded() {
            let hasSelection = false;
            let center = new THREE.Vector3();
            let count = 0;
            
            if(!currentModel) return;
            currentModel.traverse((child) => {
                if (child.isMesh && child.userData.selectedFaces && child.userData.selectedFaces.size > 0 && !child.userData.isHidden) {
                    hasSelection = true;
                    const pos = child.userData.originalGeometry.attributes.position;
                    const index = child.userData.originalGeometry.index;
                    const matrix = child.matrixWorld;
                    
                    child.userData.selectedFaces.forEach(faceIdx => {
                        const a = index.getX(faceIdx * 3);
                        const v = new THREE.Vector3().fromBufferAttribute(pos, a).applyMatrix4(matrix);
                        center.add(v);
                        count++;
                    });
                }
            });

            if (hasSelection) {
                center.divideScalar(count);
                transformProxy.position.copy(center);
                transformProxy.quaternion.copy(modelContainer.quaternion); 
                transformProxy.scale.set(1, 1, 1);
                transformControl.attach(transformProxy);
            } else {
                disableGizmo();
            }
        }

        function disableGizmo() {
            if (transformControl.object) {
                transformControl.detach();
                recalculateBaseStats();
            }
        }

        // --- Mouse System & Selection Tools ---
        function pointInPolygon(point, vs) {
            var x = point[0], y = point[1];
            var inside = false;
            for (var i = 0, j = vs.length - 1; i < vs.length; j = i++) {
                var xi = vs[i][0], yi = vs[i][1];
                var xj = vs[j][0], yj = vs[j][1];
                var intersect = ((yi > y) != (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        function setupMouseEvents() {
            container.addEventListener('pointerdown', (e) => {
                if (isGizmoDragging || transformControl.axis !== null) return; 

                const rect = container.getBoundingClientRect();
                pointerDownPos = { x: e.clientX, y: e.clientY };
                
                if (currentTool === 'box') {
                    isMarqueeSelecting = true;
                    controls.enabled = false;
                    marqueeStart.set(e.clientX - rect.left, e.clientY - rect.top);
                    marqueeEnd.copy(marqueeStart);
                    updateSelectionBoxUI();
                } else if (currentTool === 'lasso') {
                    isDragging = true;
                    controls.enabled = false;
                    lassoPoints = [[e.clientX - rect.left, e.clientY - rect.top]];
                    drawLasso();
                }
            });

            container.addEventListener('pointermove', (e) => {
                if (isGizmoDragging) return;

                const rect = container.getBoundingClientRect();
                mouse.set(((e.clientX - rect.left) / rect.width) * 2 - 1, -((e.clientY - rect.top) / rect.height) * 2 + 1);
                raycaster.setFromCamera(mouse, camera);

                if (isMarqueeSelecting) {
                    marqueeEnd.set(e.clientX - rect.left, e.clientY - rect.top);
                    updateSelectionBoxUI();
                    return;
                }

                if (currentTool === 'lasso' && isDragging) {
                    lassoPoints.push([e.clientX - rect.left, e.clientY - rect.top]);
                    drawLasso();
                    return;
                }

                if ((currentTool === 'select' || currentTool === 'wand') && transformControl.axis === null) {
                    const intersects = raycaster.intersectObject(currentModel, true);
                    const visibleIntersects = intersects.filter(hit => !hit.object.userData.isHidden);
                    updateHoverVisual(visibleIntersects.length > 0 ? visibleIntersects[0] : null);
                } else {
                    hoverMesh.visible = false;
                }
            });

            container.addEventListener('pointerup', (e) => {
                if(isGizmoDragging) return;
                
                if (currentTool === 'box' && isMarqueeSelecting) {
                    isMarqueeSelecting = false;
                    selectionBox.classList.add('hidden');
                    controls.enabled = false; // keep disabled until action is done
                    
                    if (marqueeStart.distanceTo(marqueeEnd) > 5) {
                        saveHistoryState();
                        performMarqueeSelection(e.shiftKey);
                    }
                } else if (currentTool === 'lasso' && isDragging) {
                    isDragging = false;
                    lassoCtx.clearRect(0, 0, lassoCanvas.width, lassoCanvas.height);
                    controls.enabled = false;
                    
                    if (lassoPoints.length > 2) {
                        saveHistoryState();
                        performLassoSelection(e.shiftKey);
                    }
                } else if (currentTool === 'select' || currentTool === 'wand') {
                    if (Math.abs(e.clientX - pointerDownPos.x) < 5 && Math.abs(e.clientY - pointerDownPos.y) < 5) {
                        if(transformControl.axis === null) {
                            saveHistoryState();
                            handleSelectClick(e);
                        }
                    }
                }
                
                // Reset controls state
                if(currentTool === 'select' || currentTool === 'wand') controls.enabled = true;
            });
        }
        
        function drawLasso() {
            lassoCtx.clearRect(0, 0, lassoCanvas.width, lassoCanvas.height);
            if(lassoPoints.length < 2) return;
            
            lassoCtx.beginPath();
            lassoCtx.moveTo(lassoPoints[0][0], lassoPoints[0][1]);
            for(let i=1; i<lassoPoints.length; i++) {
                lassoCtx.lineTo(lassoPoints[i][0], lassoPoints[i][1]);
            }
            lassoCtx.strokeStyle = '#3B82F6';
            lassoCtx.lineWidth = 1.5;
            lassoCtx.stroke();
            
            lassoCtx.fillStyle = 'rgba(59, 130, 246, 0.2)';
            lassoCtx.fill();
        }

        function updateSelectionBoxUI() {
            selectionBox.classList.remove('hidden');
            const left = Math.min(marqueeStart.x, marqueeEnd.x);
            const top = Math.min(marqueeStart.y, marqueeEnd.y);
            const width = Math.abs(marqueeStart.x - marqueeEnd.x);
            const height = Math.abs(marqueeStart.y - marqueeEnd.y);

            selectionBox.style.left = left + 'px';
            selectionBox.style.top = top + 'px';
            selectionBox.style.width = width + 'px';
            selectionBox.style.height = height + 'px';
        }

        function performMarqueeSelection(addMode) {
            if (!currentModel) return;
            const rect = container.getBoundingClientRect();
            const minX = Math.min(marqueeStart.x, marqueeEnd.x) / rect.width * 2 - 1;
            const maxX = Math.max(marqueeStart.x, marqueeEnd.x) / rect.width * 2 - 1;
            const minY = -(Math.max(marqueeStart.y, marqueeEnd.y) / rect.height * 2 - 1);
            const maxY = -(Math.min(marqueeStart.y, marqueeEnd.y) / rect.height * 2 - 1);

            let selectedAny = false;
            
            if(!addMode) currentModel.traverse(c => { if(c.isMesh) c.userData.selectedFaces.clear(); });

            currentModel.traverse((child) => {
                if (child.isMesh && child.userData.originalGeometry && !child.userData.isHidden) {
                    const pos = child.userData.originalGeometry.attributes.position;
                    const index = child.userData.originalGeometry.index;
                    const matrix = child.matrixWorld;
                    const deleted = child.userData.deletedFaces;
                    const vA = new THREE.Vector3(), vB = new THREE.Vector3(), vC = new THREE.Vector3();

                    for (let i = 0; i < index.count; i += 3) {
                        const faceIdx = i / 3;
                        if (deleted.has(faceIdx)) continue;

                        vA.fromBufferAttribute(pos, index.getX(i)).applyMatrix4(matrix).project(camera);
                        vB.fromBufferAttribute(pos, index.getX(i+1)).applyMatrix4(matrix).project(camera);
                        vC.fromBufferAttribute(pos, index.getX(i+2)).applyMatrix4(matrix).project(camera);

                        const isInside = (v) => v.x >= minX && v.x <= maxX && v.y >= minY && v.y <= maxY && v.z <= 1;

                        if (isInside(vA) || isInside(vB) || isInside(vC)) {
                            child.userData.selectedFaces.add(faceIdx);
                            selectedAny = true;
                        }
                    }
                }
            });

            updateSelectionVisuals();
            buildHierarchyTree();
            activateGizmoIfNeeded();
        }
        
        function performLassoSelection(addMode) {
            if (!currentModel) return;
            const rect = container.getBoundingClientRect();
            let selectedAny = false;
            
            if(!addMode) currentModel.traverse(c => { if(c.isMesh) c.userData.selectedFaces.clear(); });

            currentModel.traverse((child) => {
                if (child.isMesh && child.userData.originalGeometry && !child.userData.isHidden) {
                    const pos = child.userData.originalGeometry.attributes.position;
                    const index = child.userData.originalGeometry.index;
                    const matrix = child.matrixWorld;
                    const deleted = child.userData.deletedFaces;
                    const vA = new THREE.Vector3();

                    for (let i = 0; i < index.count; i += 3) {
                        const faceIdx = i / 3;
                        if (deleted.has(faceIdx)) continue;
                        
                        // Check using face center for speed and accuracy
                        const idxA = index.getX(i), idxB = index.getX(i+1), idxC = index.getX(i+2);
                        vA.fromBufferAttribute(pos, idxA).add(new THREE.Vector3().fromBufferAttribute(pos, idxB)).add(new THREE.Vector3().fromBufferAttribute(pos, idxC)).divideScalar(3);
                        vA.applyMatrix4(matrix).project(camera);
                        
                        // Convert back to pixel space
                        const px = (vA.x + 1) / 2 * rect.width;
                        const py = -(vA.y - 1) / 2 * rect.height;

                        if (vA.z <= 1 && pointInPolygon([px, py], lassoPoints)) {
                            child.userData.selectedFaces.add(faceIdx);
                            selectedAny = true;
                        }
                    }
                }
            });

            updateSelectionVisuals();
            buildHierarchyTree();
            activateGizmoIfNeeded();
        }

        function updateHoverVisual(hit) {
            if (!hit || hit.object.userData.isHidden) { hoverMesh.visible = false; return; }
            const child = hit.object;
            const faceIdx = hit.faceIndex;
            if (faceIdx === undefined) return;
            
            const origGeom = child.userData.originalGeometry;
            if (!origGeom || child.userData.deletedFaces.has(faceIdx)) return;
            
            const pos = origGeom.attributes.position;
            const index = origGeom.index;
            const a = index.getX(faceIdx * 3), b = index.getX(faceIdx * 3 + 1), c = index.getX(faceIdx * 3 + 2);
            
            const vA = new THREE.Vector3().fromBufferAttribute(pos, a).applyMatrix4(child.matrixWorld);
            const vB = new THREE.Vector3().fromBufferAttribute(pos, b).applyMatrix4(child.matrixWorld);
            const vC = new THREE.Vector3().fromBufferAttribute(pos, c).applyMatrix4(child.matrixWorld);
            
            hoverMesh.geometry.setAttribute('position', new THREE.Float32BufferAttribute([vA.x,vA.y,vA.z, vB.x,vB.y,vB.z, vC.x,vC.y,vC.z], 3));
            hoverMesh.visible = true;
        }

        function updateSelectionVisuals() {
            const positions = [];
            currentModel.traverse((child) => {
                if (child.isMesh && child.userData.originalGeometry && child.userData.selectedFaces && !child.userData.isHidden) {
                    const pos = child.userData.originalGeometry.attributes.position;
                    const index = child.userData.originalGeometry.index;
                    const matrix = child.matrixWorld;
                    child.userData.selectedFaces.forEach(faceIdx => {
                        const a = index.getX(faceIdx * 3), b = index.getX(faceIdx * 3 + 1), c = index.getX(faceIdx * 3 + 2);
                        const vA = new THREE.Vector3().fromBufferAttribute(pos, a).applyMatrix4(matrix);
                        const vB = new THREE.Vector3().fromBufferAttribute(pos, b).applyMatrix4(matrix);
                        const vC = new THREE.Vector3().fromBufferAttribute(pos, c).applyMatrix4(matrix);
                        positions.push(vA.x, vA.y, vA.z, vB.x, vB.y, vB.z, vC.x, vC.y, vC.z);
                    });
                }
            });
            if (positions.length > 0) {
                selectionMesh.geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                selectionMesh.visible = true;
            } else selectionMesh.visible = false;
        }

        function handleSelectClick(e) {
            const intersects = raycaster.intersectObject(currentModel, true);
            const visibleIntersects = intersects.filter(hit => !hit.object.userData.isHidden);

            if (visibleIntersects.length > 0) {
                const child = visibleIntersects[0].object;
                const hitFaceIdx = visibleIntersects[0].faceIndex;
                
                if (hitFaceIdx !== undefined && !child.userData.deletedFaces.has(hitFaceIdx)) {
                    if (!e.shiftKey) currentModel.traverse(c => { if(c.isMesh) c.userData.selectedFaces.clear(); });
                    
                    if (currentTool === 'wand') {
                        // Magic Wand BFS
                        const queue = [hitFaceIdx];
                        const visited = new Set();
                        const adj = child.userData.adjacency;
                        const index = child.userData.originalGeometry.index;
                        
                        while(queue.length > 0) {
                            const curr = queue.shift();
                            if(visited.has(curr) || child.userData.deletedFaces.has(curr)) continue;
                            
                            visited.add(curr);
                            child.userData.selectedFaces.add(curr);
                            
                            // Find neighbors
                            [index.getX(curr*3), index.getX(curr*3+1), index.getX(curr*3+2)].forEach(v => {
                                if(adj.has(v)) {
                                    adj.get(v).forEach(neighbor => {
                                        if(!visited.has(neighbor)) queue.push(neighbor);
                                    });
                                }
                            });
                        }
                    } else {
                        // Single Select
                        if (e.shiftKey && child.userData.selectedFaces.has(hitFaceIdx)) child.userData.selectedFaces.delete(hitFaceIdx);
                        else child.userData.selectedFaces.add(hitFaceIdx);
                    }
                    
                    updateSelectionVisuals();
                    buildHierarchyTree();
                    activateGizmoIfNeeded();
                }
            } else {
                if (!e.shiftKey) {
                    currentModel.traverse(c => { if(c.isMesh) c.userData.selectedFaces.clear(); });
                    updateSelectionVisuals();
                    disableGizmo();
                    buildHierarchyTree();
                }
            }
        }

        function deleteSelectedFaces() {
            let deletedAny = false;
            saveHistoryState();
            disableGizmo();
            
            currentModel.traverse((child) => {
                if (child.isMesh && child.userData.selectedFaces && child.userData.selectedFaces.size > 0 && !child.userData.isHidden) {
                    child.userData.selectedFaces.forEach(faceIdx => child.userData.deletedFaces.add(faceIdx));
                    child.userData.selectedFaces.clear();
                    deletedAny = true;
                }
            });
            if (deletedAny) {
                updateSelectionVisuals();
                hoverMesh.visible = false;
                resetGeometryForErasing();
                recalculateBaseStats();
                buildHierarchyTree();
            } else {
                historyStack.pop();
            }
        }

        // Extract & Duplicate Tools
        function performExtractionOrDuplication(isExtract) {
            saveHistoryState();
            let createdAny = false;
            const newMeshesToAttach = [];

            currentModel.traverse((child) => {
                if (child.isMesh && child.userData.selectedFaces && child.userData.selectedFaces.size > 0 && !child.userData.isHidden) {
                    const origGeom = child.userData.originalGeometry;
                    const pos = origGeom.attributes.position;
                    const norm = origGeom.attributes.normal;
                    const index = origGeom.index;

                    const newIndices = [];
                    const map = new Map();
                    let newIdx = 0;
                    const newPos = [], newNorm = [];

                    child.userData.selectedFaces.forEach(faceIdx => {
                        const a = index.getX(faceIdx * 3), b = index.getX(faceIdx * 3 + 1), c = index.getX(faceIdx * 3 + 2);
                        [a, b, c].forEach(idx => {
                            if(!map.has(idx)) {
                                map.set(idx, newIdx++);
                                newPos.push(pos.getX(idx), pos.getY(idx), pos.getZ(idx));
                                if(norm) newNorm.push(norm.getX(idx), norm.getY(idx), norm.getZ(idx));
                            }
                        });
                        newIndices.push(map.get(a), map.get(b), map.get(c));
                    });

                    const newGeom = new THREE.BufferGeometry();
                    newGeom.setAttribute('position', new THREE.Float32BufferAttribute(newPos, 3));
                    if(norm) newGeom.setAttribute('normal', new THREE.Float32BufferAttribute(newNorm, 3));
                    newGeom.setIndex(newIndices);

                    const newMesh = new THREE.Mesh(newGeom, child.material);
                    newMesh.name = (child.name || "Part") + (isExtract ? "_Extracted" : "_Duplicate");
                    newMesh.position.copy(child.position);
                    newMesh.quaternion.copy(child.quaternion);
                    newMesh.scale.copy(child.scale);

                    newMesh.userData.originalGeometry = newGeom.clone();
                    newMesh.userData.deletedFaces = new Set();
                    newMesh.userData.selectedFaces = new Set();
                    newMesh.userData.isHidden = false;
                    buildAdjacencyList(newMesh);

                    newMeshesToAttach.push({parent: child.parent, mesh: newMesh});

                    if (isExtract) {
                        child.userData.selectedFaces.forEach(faceIdx => child.userData.deletedFaces.add(faceIdx));
                    }
                    child.userData.selectedFaces.clear();
                    createdAny = true;
                }
            });

            if (createdAny) {
                newMeshesToAttach.forEach(item => item.parent.add(item.mesh));
                disableGizmo();
                updateSelectionVisuals();
                resetGeometryForErasing();
                recalculateBaseStats();
                buildHierarchyTree();
            } else {
                historyStack.pop();
                alert("Please select faces to " + (isExtract ? "extract" : "duplicate") + ".");
            }
        }

        btnActionExtract.addEventListener('click', () => performExtractionOrDuplication(true));
        btnActionDuplicate.addEventListener('click', () => performExtractionOrDuplication(false));

        btnClearSel.addEventListener('click', () => {
            saveHistoryState();
            disableGizmo();
            currentModel.traverse((child) => { if (child.isMesh && child.userData.selectedFaces) child.userData.selectedFaces.clear(); });
            updateSelectionVisuals();
            buildHierarchyTree();
        });

        // --- Decimation (Manual Apply) ---
        function getCleanBaseGeometry(child) {
            const orig = child.userData.originalGeometry;
            const deleted = child.userData.deletedFaces;
            let cleanGeom;
            if (!deleted || deleted.size === 0) {
                 cleanGeom = orig.clone();
            } else {
                const pos = orig.attributes.position;
                const norm = orig.attributes.normal;
                const index = orig.index;
                const map = new Map();
                let newIdx = 0;
                const newPos = [], newNorm = [], newIndices = [];
                
                for(let i=0; i<index.count; i+=3) {
                    if(!deleted.has(i / 3)) {
                        const a = index.getX(i), b = index.getX(i+1), c = index.getX(i+2);
                        [a, b, c].forEach(idx => {
                            if(!map.has(idx)) {
                                map.set(idx, newIdx++);
                                newPos.push(pos.getX(idx), pos.getY(idx), pos.getZ(idx));
                                if(norm) newNorm.push(norm.getX(idx), norm.getY(idx), norm.getZ(idx));
                            }
                        });
                        newIndices.push(map.get(a), map.get(b), map.get(c));
                    }
                }
                cleanGeom = new THREE.BufferGeometry();
                cleanGeom.setAttribute('position', new THREE.Float32BufferAttribute(newPos, 3));
                if(norm) cleanGeom.setAttribute('normal', new THREE.Float32BufferAttribute(newNorm, 3));
                cleanGeom.setIndex(newIndices);
            }
            try {
                cleanGeom = BufferGeometryUtils.mergeVertices(cleanGeom, 1e-4);
                cleanGeom.computeVertexNormals();
            } catch (e) { }
            return cleanGeom;
        }

        function resetGeometryForErasing() {
            if(!currentModel) return;
            currentModel.traverse((child) => {
                if(child.isMesh && child.userData.originalGeometry) {
                    const origGeom = child.userData.originalGeometry.clone();
                    const origIndex = origGeom.index;
                    const deleted = child.userData.deletedFaces;
                    const newIndices = [];
                    for (let i = 0; i < origIndex.count; i += 3) {
                        if (!deleted.has(i / 3)) newIndices.push(origIndex.getX(i), origIndex.getX(i+1), origIndex.getX(i+2));
                    }
                    origGeom.setIndex(newIndices);
                    if(child.geometry !== child.userData.originalGeometry) child.geometry.dispose();
                    child.geometry = origGeom;
                }
            });
            updateLiveStats();
        }

        simplifySlider.addEventListener('input', (e) => {
            const val = parseInt(e.target.value);
            targetVal.textContent = val.toLocaleString();
        });

        btnApplyDecimate.addEventListener('click', () => {
            if (!currentModel) return;
            const targetTris = parseInt(simplifySlider.value);
            
            showLoading(true, "DECIMATING MESH...");

            setTimeout(() => {
                if (targetTris >= baseStats.triangles || document.getElementById('target-type').value === 'full') {
                    resetGeometryForErasing(); 
                } else {
                    const reductionRatio = targetTris / baseStats.triangles;
                    const modifier = new SimplifyModifier();

                    currentModel.traverse((child) => {
                        if (child.isMesh && child.userData.originalGeometry && !child.userData.isHidden) {
                            try {
                                const cleanGeom = getCleanBaseGeometry(child);
                                const currentVertices = cleanGeom.attributes.position.count;
                                const oldGeom = child.geometry;
                                const targetMeshVerts = Math.max(3, Math.floor(currentVertices * reductionRatio));
                                const countToRemove = currentVertices - targetMeshVerts;

                                if (countToRemove > 0) {
                                    const simplifiedGeom = modifier.modify(cleanGeom, countToRemove);
                                    simplifiedGeom.computeVertexNormals();
                                    child.geometry = simplifiedGeom;
                                } else {
                                    child.geometry = cleanGeom;
                                }
                                
                                if (oldGeom !== child.userData.originalGeometry) oldGeom.dispose();
                            } catch(e) { console.warn("Topology too complex/broken for decimation on part", child.name); }
                        }
                    });
                }
                updateLiveStats();
                showLoading(false);
            }, 50);
        });

        function showLoading(show, text="PROCESSING...") {
            document.getElementById('loading-text').textContent = text;
            if (show) document.getElementById('loading-overlay').classList.remove('hidden');
            else document.getElementById('loading-overlay').classList.add('hidden');
        }

        // --- Export LFS .OBJ ---
        btnConvert.addEventListener('click', () => {
            if (!currentModel) return;
            
            const target = targetTypeSelect.value;
            if (target !== 'full' && (modelStats.vertices > LIMITS[target].verts || modelStats.triangles > LIMITS[target].polys)) {
                const confirmExport = confirm(`Warning: Model exceeds limits for ${target}. It may fail to import. Export anyway?`);
                if (!confirmExport) return;
            }

            showLoading(true, "GENERATING LFS .OBJ...");
            setTimeout(() => {
                const objBlob = generateOBJBlob(currentModel);
                downloadBlob(objBlob, `${originalFileName}.obj`);
                showLoading(false);
            }, 100);
        });

        function generateOBJBlob(modelScene) {
            let output = "# Exported for Live for Speed Editor\n# Coordinate System: Y forward, Z up\n\n";
            let globalVertexOffset = 1;

            modelContainer.updateMatrixWorld(true);
            
            modelScene.traverse((child) => {
                if (child.isMesh && child.geometry && child.geometry.index && !child.userData.isHidden) {
                    const geom = child.geometry;
                    const pos = geom.attributes.position;
                    const norm = geom.attributes.normal;
                    const index = geom.index;
                    
                    output += `o ${child.name || 'Mesh'}\n`;
                    const matrix = child.matrixWorld;
                    const normalMatrix = new THREE.Matrix3().getNormalMatrix(matrix);
                    
                    const usedIndices = new Set();
                    for (let i = 0; i < index.count; i++) usedIndices.add(index.getX(i));
                    
                    const indexMap = new Map();
                    let localNewIndex = 0;
                    const v = new THREE.Vector3(), n = new THREE.Vector3();
                    
                    for (let i = 0; i < pos.count; i++) {
                        if (usedIndices.has(i)) {
                            indexMap.set(i, globalVertexOffset + localNewIndex);
                            localNewIndex++;
                            v.fromBufferAttribute(pos, i).applyMatrix4(matrix); 
                            output += `v ${v.x.toFixed(6)} ${-v.z.toFixed(6)} ${v.y.toFixed(6)}\n`;
                        }
                    }
                    
                    if (norm) {
                        for (let i = 0; i < pos.count; i++) {
                            if (usedIndices.has(i)) {
                                n.fromBufferAttribute(norm, i).applyMatrix3(normalMatrix).normalize();
                                output += `vn ${n.x.toFixed(6)} ${-n.z.toFixed(6)} ${n.y.toFixed(6)}\n`;
                            }
                        }
                    }
                    
                    for (let i = 0; i < index.count; i += 3) {
                        const a = indexMap.get(index.getX(i)), b = indexMap.get(index.getX(i+1)), c = indexMap.get(index.getX(i+2));
                        if (norm) output += `f ${a}//${a} ${b}//${b} ${c}//${c}\n`;
                        else output += `f ${a} ${b} ${c}\n`;
                    }
                    globalVertexOffset += usedIndices.size;
                    output += '\n';
                }
            });
            return new Blob([output], { type: 'text/plain' });
        }

        function downloadBlob(blob, filename) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);
        }

        initThreeJS();

    </script>
</body>
</html>
