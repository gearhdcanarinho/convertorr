<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modder's GLB to OBJ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #030712; color: #D1D5DB; user-select: none; }
        #canvas-container { width: 100%; height: 100%; display: block; outline: none; }
        
        /* Custom Scrollbar - Black/Blue Theme */
        .custom-scrollbar::-webkit-scrollbar { width: 6px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: #09090b; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #1e3a8a; border-radius: 3px; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #2563eb; }
        
        /* Cursors */
        .cursor-select { cursor: crosshair !important; }
        .cursor-lasso { cursor: crosshair !important; }
        .cursor-wand { cursor: crosshair !important; }
        
        /* Hierarchy Tree Styles */
        .tree-item { display: flex; align-items: center; justify-content: space-between; padding: 4px 6px; border-radius: 4px; margin-bottom: 2px; border: 1px solid transparent; background: #09090b; }
        .tree-item:hover { background-color: #172554; }
        .tree-item.selected { background-color: #1E3A8A; border-color: #2563EB; }
        .tree-item-name { cursor: pointer; flex-grow: 1; font-size: 11px; color: #D1D5DB; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; padding-right: 8px;}
        .tree-item-name:hover { color: #60A5FA; }
        .visibility-toggle { cursor: pointer; color: #9CA3AF; padding: 2px; }
        .visibility-toggle:hover { color: #F3F4F6; }
        .visibility-hidden { color: #4B5563; }
        
        /* Toolbar buttons */
        .tool-btn { @apply w-10 h-10 flex items-center justify-center rounded-lg bg-[#09090b] text-gray-400 hover:bg-[#172554] hover:text-white transition-all border border-gray-800; }
        .tool-btn.active { @apply bg-blue-600 text-white border-blue-400 shadow-[0_0_12px_rgba(37,99,235,0.5)]; }
        
        /* Canvas for Lasso */
        #lasso-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 20; }
        
        /* Modal Animation */
        .modal-enter { animation: fadeIn 0.3s ease-out forwards; }
        @keyframes fadeIn { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }
    </style>
    <!-- Import Maps for Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body class="flex h-screen font-sans text-xs flex-col">

    <!-- INTRO SPLASH SCREEN -->
    <div id="intro-modal" class="fixed inset-0 z-50 bg-black/90 flex items-center justify-center backdrop-blur-md">
        <div class="bg-gray-900 border border-blue-900 rounded-xl shadow-2xl p-8 max-w-2xl modal-enter relative overflow-hidden">
            <div class="absolute top-0 left-0 w-full h-1 bg-gradient-to-r from-blue-600 to-emerald-500"></div>
            <h1 class="text-3xl font-bold text-white mb-2">Bem-vindo ao Modder's GLB Converter</h1>
            <p class="text-gray-400 text-sm mb-6">A ferramenta definitiva no navegador para preparar e otimizar modelos 3D para engines clássicas (como Live for Speed).</p>
            
            <div class="grid grid-cols-2 gap-6 mb-8 text-sm">
                <div class="space-y-3">
                    <h3 class="text-blue-400 font-bold border-b border-gray-800 pb-1">Navegação da Câmera</h3>
                    <ul class="text-gray-300 space-y-1">
                        <li><kbd class="bg-gray-800 px-1.5 rounded text-xs text-blue-300">Num 1</kbd> Visão Frontal</li>
                        <li><kbd class="bg-gray-800 px-1.5 rounded text-xs text-blue-300">Num 3</kbd> Visão Lateral Direita</li>
                        <li><kbd class="bg-gray-800 px-1.5 rounded text-xs text-blue-300">Num 7</kbd> Visão do Topo</li>
                        <li><kbd class="bg-gray-800 px-1.5 rounded text-xs text-blue-300">Num 9</kbd> Visão Inferior</li>
                        <li><kbd class="bg-gray-800 px-1.5 rounded text-xs text-blue-300">Botão Esquerdo</kbd> Rotacionar Câmera</li>
                        <li><kbd class="bg-gray-800 px-1.5 rounded text-xs text-blue-300">Botão Direito</kbd> Mover (Pan)</li>
                    </ul>
                </div>
                <div class="space-y-3">
                    <h3 class="text-blue-400 font-bold border-b border-gray-800 pb-1">Atalhos de Ferramentas</h3>
                    <ul class="text-gray-300 space-y-1">
                        <li><kbd class="bg-gray-800 px-1.5 rounded text-xs text-emerald-300">V</kbd> Seleção Padrão (Click)</li>
                        <li><kbd class="bg-gray-800 px-1.5 rounded text-xs text-emerald-300">M</kbd> Seleção Retangular (Marquee)</li>
                        <li><kbd class="bg-gray-800 px-1.5 rounded text-xs text-emerald-300">L</kbd> Laço à mão livre (Lasso)</li>
                        <li><kbd class="bg-gray-800 px-1.5 rounded text-xs text-emerald-300">W</kbd> Varinha Mágica (Peças interligadas)</li>
                        <li><kbd class="bg-gray-800 px-1.5 rounded text-xs text-red-300">Del</kbd> Apagar Polígonos Selecionados</li>
                        <li><kbd class="bg-gray-800 px-1.5 rounded text-xs text-yellow-300">Ctrl+Z</kbd> Desfazer Ação</li>
                    </ul>
                </div>
            </div>

            <button id="btn-start-app" class="w-full bg-blue-600 hover:bg-blue-500 text-white font-bold py-3 rounded-lg shadow-lg transition-all text-base">
                Começar a Editar Projetos
            </button>
        </div>
    </div>

    <!-- PROJECTS MODAL -->
    <div id="projects-modal" class="hidden fixed inset-0 z-50 bg-black/80 flex items-center justify-center backdrop-blur-sm">
        <div class="bg-gray-900 border border-gray-700 rounded-lg shadow-2xl p-6 w-96 modal-enter">
            <h2 class="text-xl font-bold text-white mb-4">Local Workspaces</h2>
            <p class="text-xs text-gray-400 mb-4">Os projetos são salvos no cache do seu navegador.</p>
            
            <div id="projects-list" class="max-h-60 overflow-y-auto custom-scrollbar space-y-2 mb-4 bg-gray-950 p-2 rounded border border-gray-800">
                <!-- List of projects goes here -->
            </div>

            <div class="flex gap-2">
                <button id="btn-save-project" class="flex-1 bg-emerald-600 hover:bg-emerald-500 text-white font-bold py-2 rounded transition-all">Save Current</button>
                <button id="btn-close-projects" class="flex-1 bg-gray-700 hover:bg-gray-600 text-white font-bold py-2 rounded transition-all">Close</button>
            </div>
        </div>
    </div>

    <!-- MAIN UI WRAPPER -->
    <div class="flex flex-grow overflow-hidden relative">
        
        <!-- LEFT PANEL: Tool Shelf -->
        <div class="w-16 bg-[#030712] border-r border-gray-800 flex flex-col items-center py-4 gap-3 z-10 shadow-xl">
            <div class="text-[9px] text-gray-600 font-bold mb-1 tracking-widest">TOOLS</div>
            
            <button id="tool-select" class="tool-btn active" title="Select (V)">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 15l-2 5L9 9l11 4-5 2zm0 0l5 5M7.188 2.239l.777 2.897M5.136 7.965l-2.898-.777M13.95 4.05l-2.122 2.122m-5.657 5.656l-2.12 2.122"></path></svg>
            </button>
            <button id="tool-box" class="tool-btn" title="Box / Marquee (M)">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4h4v4H4zM16 4h4v4h-4zM4 16h4v4H4zM16 16h4v4h-4zM8 6h8M8 18h8M6 8v8M18 8v8"></path></svg>
            </button>
            <button id="tool-lasso" class="tool-btn" title="Lasso Select (L)">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A4 4 0 002 9v11a2 2 0 002 2h10a2 2 0 002-2v-5.655l-1.248-.832zM16 3a3 3 0 11-6 0 3 3 0 016 0z"></path></svg>
            </button>
            <button id="tool-wand" class="tool-btn" title="Magic Wand / Linked Faces (W)">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19.428 15.428a2 2 0 00-1.022-.547l-2.387-.477a6 6 0 00-3.86.517l-.318.158a6 6 0 01-3.86.517L6.05 15.21a2 2 0 00-1.806.547M8 4h8l-1 1v5.172a2 2 0 00.586 1.414l5 5c1.26 1.26.367 3.414-1.415 3.414H4.828c-1.782 0-2.674-2.154-1.414-3.414l5-5A2 2 0 009 10.172V5L8 4z"></path></svg>
            </button>

            <div class="w-8 h-px bg-gray-800 my-2"></div>
            <div class="text-[9px] text-gray-600 font-bold mb-1 tracking-widest">GIZMO</div>

            <!-- Gizmo Icons Diferenciados -->
            <button id="gizmo-translate" class="tool-btn active" title="Move">
                <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 0a.5.5 0 0 1 .5.5v7h7a.5.5 0 0 1 0 1h-7v7a.5.5 0 0 1-1 0v-7h-7a.5.5 0 0 1 0-1h7v-7A.5.5 0 0 1 8 0zM4.146 4.146a.5.5 0 0 1 .708 0L8 7.293l3.146-3.147a.5.5 0 0 1 .708.708L8.707 8l3.147 3.146a.5.5 0 0 1-.708.708L8 8.707l-3.146 3.147a.5.5 0 0 1-.708-.708L7.293 8 4.146 4.854a.5.5 0 0 1 0-.708z"/></svg>
            </button>
            <button id="gizmo-rotate" class="tool-btn" title="Rotate">
                <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z"/><path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466z"/></svg>
            </button>
            <button id="gizmo-scale" class="tool-btn" title="Scale">
                <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M5 3.5a.5.5 0 0 1 .5-.5h2a.5.5 0 0 1 0 1H6.707l2.147 2.146a.5.5 0 1 1-.708.708L6 4.707V6a.5.5 0 0 1-1 0v-2.5zM11 3.5a.5.5 0 0 1 .5-.5h2a.5.5 0 0 1 .5.5v2.5a.5.5 0 0 1-1 0V4.707l-2.146 2.147a.5.5 0 0 1-.708-.708L12.293 4H11.5a.5.5 0 0 1-.5-.5zM5 12.5a.5.5 0 0 1 .5-.5h2a.5.5 0 0 1 0 1H6.707l2.147-2.146a.5.5 0 0 1-.708-.708L6 11.293V12.5a.5.5 0 0 1-1 0v-2.5zM11 12.5a.5.5 0 0 1 .5-.5h2a.5.5 0 0 1 .5.5v2.5a.5.5 0 0 1-1 0v-1.293l-2.146 2.147a.5.5 0 0 1-.708-.708L12.293 12H11.5a.5.5 0 0 1-.5-.5z"/></svg>
            </button>
        </div>

        <!-- CENTER PANEL: 3D Viewport -->
        <div class="flex-grow relative bg-gray-950 flex flex-col">
            <!-- Top Toolbar over Viewport -->
            <div class="absolute top-0 left-0 w-full p-3 pointer-events-none flex justify-between z-10">
                <div class="flex gap-2 pointer-events-auto">
                    <label for="file-upload" class="bg-blue-600 hover:bg-blue-500 text-white px-4 py-1.5 rounded shadow cursor-pointer font-bold flex items-center gap-2">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path></svg>
                        Import GLB
                    </label>
                    <input id="file-upload" type="file" class="hidden" accept=".glb" />
                    
                    <button id="btn-projects" class="bg-indigo-600 hover:bg-indigo-500 text-white px-3 py-1.5 rounded shadow transition-all font-bold flex items-center gap-2">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3m-1 4l-3 3m0 0l-3-3m3 3V4"></path></svg>
                        Workspaces
                    </button>

                    <button id="btn-undo" class="bg-[#09090b] border border-gray-800 hover:bg-gray-800 text-white px-3 py-1.5 rounded shadow opacity-50 cursor-not-allowed transition-all" title="Undo (Ctrl+Z)">
                        Undo
                    </button>
                    <button id="btn-wireframe" class="bg-[#09090b] border border-gray-800 hover:bg-gray-800 text-white px-3 py-1.5 rounded shadow transition-all">
                        Wireframe
                    </button>
                    
                    <!-- Background Color Picker -->
                    <div class="flex items-center gap-2 bg-[#09090b] border border-gray-800 px-2 py-1.5 rounded shadow">
                        <span class="text-[10px] text-gray-400" title="Viewport Background Color">BG:</span>
                        <input type="color" id="bg-color" value="#030712" class="w-5 h-5 rounded cursor-pointer border-0 bg-transparent p-0">
                    </div>
                </div>
            </div>

            <canvas id="lasso-canvas"></canvas>
            <div id="selection-box" class="hidden absolute border border-blue-400 bg-blue-500/20 pointer-events-none z-30"></div>
            <div id="canvas-container" tabindex="0" class="flex-grow w-full h-full outline-none"></div>

            <!-- Loading Overlay -->
            <div id="loading-overlay" class="absolute inset-0 z-40 bg-gray-950/90 flex items-center justify-center hidden backdrop-blur-sm">
                <div class="flex flex-col items-center">
                    <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500 mb-4"></div>
                    <p id="loading-text" class="text-blue-400 font-bold tracking-widest uppercase">PROCESSING...</p>
                </div>
            </div>
        </div>

        <!-- RIGHT PANEL: Outliner & Properties -->
        <div class="w-80 bg-[#030712] border-l border-gray-800 flex flex-col z-10 shadow-xl overflow-y-auto custom-scrollbar">
            
            <!-- Outliner / Hierarchy -->
            <div class="p-4 border-b border-gray-800 flex-grow max-h-[50vh] flex flex-col">
                <div class="flex justify-between items-end mb-3">
                    <h2 class="text-sm font-bold text-gray-200 flex items-center gap-2">
                        <svg class="w-4 h-4 text-blue-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10"></path></svg>
                        Outliner
                    </h2>
                    <span id="filename-display" class="text-[10px] text-gray-500 truncate max-w-[120px]">No model</span>
                </div>
                
                <div id="hierarchy-list" class="flex-grow overflow-y-auto custom-scrollbar bg-[#09090b] rounded border border-gray-800 p-1 space-y-0.5">
                    <div class="text-gray-600 text-center italic py-4">Import a model first</div>
                </div>

                <!-- Modding Actions -->
                <div class="grid grid-cols-2 gap-2 mt-3">
                    <button id="btn-action-extract" class="py-1.5 bg-[#09090b] hover:bg-gray-800 border border-gray-800 text-gray-300 rounded shadow transition-all">Extract Part</button>
                    <button id="btn-action-duplicate" class="py-1.5 bg-[#09090b] hover:bg-gray-800 border border-gray-800 text-gray-300 rounded shadow transition-all">Duplicate</button>
                    <button id="btn-obj-mirror" class="py-1.5 bg-[#09090b] hover:bg-gray-800 border border-gray-800 text-gray-300 rounded shadow transition-all">Mirror (X)</button>
                    <button id="btn-obj-center" class="py-1.5 bg-[#09090b] hover:bg-gray-800 border border-gray-800 text-gray-300 rounded shadow transition-all">Center Pivot</button>
                </div>
                <div class="flex gap-2 mt-2">
                    <button id="btn-clear-sel" class="flex-1 py-1.5 bg-[#09090b] hover:bg-gray-800 border border-gray-800 text-gray-400 rounded">Clear Sel.</button>
                    <button id="btn-delete-sel" class="flex-1 py-1.5 bg-red-900/20 hover:bg-red-900/40 border border-red-900/30 text-red-400 rounded transition-all">Delete (Del)</button>
                </div>
            </div>

            <!-- Properties / Export -->
            <div class="p-4 bg-[#09090b] flex-grow flex flex-col justify-between">
                
                <div class="space-y-4">
                    <h2 class="text-sm font-bold text-gray-200 flex items-center gap-2">
                        <svg class="w-4 h-4 text-emerald-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6V4m0 2a2 2 0 100 4m0-4a2 2 0 110 4m-6 8a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4m6 6v10m6-2a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4"></path></svg>
                        Properties
                    </h2>
                    
                    <!-- Target Profiles -->
                    <div>
                        <label class="text-[10px] text-gray-500 uppercase tracking-wider mb-1 block">Export Target Profile</label>
                        <select id="target-type" class="w-full bg-[#030712] border border-gray-800 text-gray-300 text-xs rounded p-2 focus:border-blue-500 focus:outline-none">
                            <option value="full">Target: Full Poly (Original / No Limits)</option>
                            <option value="car">Target: Car Body (Max 32k Verts)</option>
                            <option value="wheel" selected>Target: Wheel (Max 4,240 Polys)</option>
                        </select>
                    </div>

                    <!-- Stats -->
                    <div class="bg-[#030712] rounded border border-gray-800 p-2 text-xs">
                        <p class="flex justify-between items-center mb-1">
                            <span class="text-gray-500">Vertices:</span>
                            <span id="stat-verts" class="font-mono text-gray-300">0</span>
                        </p>
                        <p class="flex justify-between items-center">
                            <span class="text-gray-500">Triangles:</span>
                            <span id="stat-tris" class="font-mono text-gray-300">0</span>
                        </p>
                        <div id="poly-warning" class="hidden mt-2 p-1 bg-red-900/30 border border-red-900/50 text-red-400 text-[9px] text-center rounded">
                            EXCEEDS ENGINE LIMITS
                        </div>
                    </div>

                    <!-- Manual Decimation -->
                    <div id="decimate-block" class="bg-[#030712] rounded border border-gray-800 p-3 transition-opacity duration-300">
                        <div class="flex justify-between text-[10px] mb-2">
                            <span class="text-gray-400">Target Polys:</span>
                            <span id="target-val" class="text-blue-400 font-mono font-bold">...</span>
                        </div>
                        <input type="range" id="simplify-slider" min="100" max="32768" value="32000" class="w-full accent-blue-500 h-1 mb-3">
                        <button id="btn-apply-decimate" class="w-full py-1.5 bg-blue-600 hover:bg-blue-500 text-white font-bold rounded shadow transition-all disabled:opacity-50 disabled:cursor-not-allowed">
                            Apply Optimization
                        </button>
                    </div>
                </div>

                <!-- Export -->
                <div class="mt-4 flex flex-col gap-2">
                    <button id="btn-convert-sel" disabled class="w-full py-2 bg-[#030712] text-gray-500 font-bold rounded-lg cursor-not-allowed transition-all border border-gray-800 hover:bg-gray-800 hover:text-white">
                        Export Selected (.OBJ)
                    </button>
                    <button id="btn-convert" disabled class="w-full py-3 bg-gray-800 text-gray-500 font-bold rounded-lg cursor-not-allowed transition-all border border-gray-700">
                        Export Full Scene (.OBJ)
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- BOTTOM STATUS BAR -->
    <div id="status-bar" class="w-full bg-[#09090b] border-t border-gray-800 text-gray-400 text-[10px] px-4 py-1.5 flex justify-between z-20 shadow-inner">
        <span id="status-text"><strong class="text-blue-400">V</strong>: Select Tool | <strong class="text-blue-400">Shift+Click</strong>: Add to selection</span>
        <span class="text-gray-600">LFS Modder's Toolkit</span>
    </div>

    <!-- Main Logic -->
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { SimplifyModifier } from 'three/addons/modifiers/SimplifyModifier.js';
        import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';

        // --- App State ---
        let scene, camera, renderer, controls;
        let modelContainer;
        let currentModel = null;
        let maxModelDimension = 1;
        let currentGlbBuffer = null; // Para salvar no banco local
        
        let modelStats = { vertices: 0, triangles: 0 };
        let baseStats = { vertices: 0, triangles: 0 }; 
        let originalFileName = "model";

        const LIMITS = {
            full: { verts: Infinity, polys: Infinity },
            car: { verts: 32768, polys: 65536 },
            wheel: { verts: 32768, polys: 4240 }
        };

        // --- Tool State ---
        let currentTool = 'select'; // 'select', 'box', 'lasso', 'wand'
        let isDragging = false;
        let pointerDownPos = { x: 0, y: 0 };
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let isWireframeActive = false;
        
        // Lasso State
        const lassoCanvas = document.getElementById('lasso-canvas');
        const lassoCtx = lassoCanvas.getContext('2d');
        let lassoPoints = [];
        
        // Marquee State
        let isMarqueeSelecting = false;
        let marqueeStart = new THREE.Vector2();
        let marqueeEnd = new THREE.Vector2();

        // Undo History
        let historyStack = [];
        const MAX_HISTORY = 20;

        // Advanced Gizmo State
        let transformControl, transformProxy;
        let isGizmoDragging = false;
        let currentGizmoMode = 'translate';
        let proxyLocalVertices = new Map();
        let initialProxyMatrixInv = new THREE.Matrix4();

        // Visual Elements
        let hoverMesh, selectionMesh;

        // --- DOM Elements ---
        const container = document.getElementById('canvas-container');
        const selectionBox = document.getElementById('selection-box');
        const fileInput = document.getElementById('file-upload');
        const btnConvert = document.getElementById('btn-convert');
        const btnConvertSel = document.getElementById('btn-convert-sel');
        const loadingOverlay = document.getElementById('loading-overlay');
        const loadingText = document.getElementById('loading-text');
        
        const hierarchyList = document.getElementById('hierarchy-list');
        const btnWireframe = document.getElementById('btn-wireframe');
        const bgColorPicker = document.getElementById('bg-color');
        
        const targetTypeSelect = document.getElementById('target-type');
        const statVerts = document.getElementById('stat-verts');
        const statTris = document.getElementById('stat-tris');
        const vertWarning = document.getElementById('vert-warning');
        const polyWarning = document.getElementById('poly-warning');
        const decimateBlock = document.getElementById('decimate-block');
        
        const toolBtns = {
            select: document.getElementById('tool-select'),
            box: document.getElementById('tool-box'),
            lasso: document.getElementById('tool-lasso'),
            wand: document.getElementById('tool-wand')
        };
        
        const statusText = document.getElementById('status-text');
        
        const btnActionExtract = document.getElementById('btn-action-extract');
        const btnActionDuplicate = document.getElementById('btn-action-duplicate');
        const btnObjMirror = document.getElementById('btn-obj-mirror');
        const btnObjCenter = document.getElementById('btn-obj-center');

        const btnDeleteSel = document.getElementById('btn-delete-sel');
        const btnClearSel = document.getElementById('btn-clear-sel');
        const btnUndo = document.getElementById('btn-undo');

        const simplifySlider = document.getElementById('simplify-slider');
        const btnApplyDecimate = document.getElementById('btn-apply-decimate');
        const targetVal = document.getElementById('target-val');

        // Intro / DB UI
        document.getElementById('btn-start-app').addEventListener('click', () => {
            document.getElementById('intro-modal').classList.add('hidden');
        });
        document.getElementById('btn-projects').addEventListener('click', () => {
            document.getElementById('projects-modal').classList.remove('hidden');
            loadProjectsList();
        });
        document.getElementById('btn-close-projects').addEventListener('click', () => {
            document.getElementById('projects-modal').classList.add('hidden');
        });

        // --- Init Three.js ---
        function initThreeJS() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(bgColorPicker.value);
            
            modelContainer = new THREE.Group();
            scene.add(modelContainer);
            
            const gridHelper = new THREE.GridHelper(10, 10, 0x222222, 0x111111);
            scene.add(gridHelper);

            camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(3, 3, 5);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            container.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // --- Gizmos ---
            transformProxy = new THREE.Object3D();
            scene.add(transformProxy);

            transformControl = new TransformControls(camera, renderer.domElement);
            transformControl.size = 0.7;
            
            transformControl.addEventListener('dragging-changed', function (event) {
                controls.enabled = !event.value;
                isGizmoDragging = event.value;

                if (event.value) {
                    saveHistoryState();
                    initialProxyMatrixInv.copy(transformProxy.matrixWorld).invert();
                    proxyLocalVertices.clear();
                    
                    currentModel.traverse((child) => {
                        if (child.isMesh && child.userData.selectedFaces && child.userData.selectedFaces.size > 0 && !child.userData.isHidden) {
                            const index = child.userData.originalGeometry.index;
                            const pos = child.userData.originalGeometry.attributes.position;
                            child.userData.selectedFaces.forEach(faceIdx => {
                                const a = index.getX(faceIdx * 3), b = index.getX(faceIdx * 3 + 1), c = index.getX(faceIdx * 3 + 2);
                                [a, b, c].forEach(idx => {
                                    const key = child.uuid + '_' + idx;
                                    if (!proxyLocalVertices.has(key)) {
                                        const vLocal = new THREE.Vector3().fromBufferAttribute(pos, idx);
                                        const vWorld = vLocal.applyMatrix4(child.matrixWorld);
                                        const vProxy = vWorld.applyMatrix4(initialProxyMatrixInv);
                                        proxyLocalVertices.set(key, vProxy);
                                    }
                                });
                            });
                        }
                    });
                } else {
                    recalculateBaseStats();
                }
            });

            transformControl.addEventListener('change', () => {
                if (!isGizmoDragging) return;
                
                currentModel.traverse((child) => {
                    if (child.isMesh && child.userData.selectedFaces && child.userData.selectedFaces.size > 0 && !child.userData.isHidden) {
                        const pos = child.userData.originalGeometry.attributes.position;
                        const invMeshWorld = child.matrixWorld.clone().invert();
                        
                        child.userData.selectedFaces.forEach(faceIdx => {
                            const index = child.userData.originalGeometry.index;
                            const a = index.getX(faceIdx * 3), b = index.getX(faceIdx * 3 + 1), c = index.getX(faceIdx * 3 + 2);
                            
                            [a, b, c].forEach(idx => {
                                const key = child.uuid + '_' + idx;
                                const vProxyLocal = proxyLocalVertices.get(key);
                                if (vProxyLocal) {
                                    const newWorldV = vProxyLocal.clone().applyMatrix4(transformProxy.matrixWorld);
                                    const newLocalV = newWorldV.applyMatrix4(invMeshWorld);
                                    pos.setXYZ(idx, newLocalV.x, newLocalV.y, newLocalV.z);
                                }
                            });
                        });
                        
                        pos.needsUpdate = true;
                        if (child.geometry.attributes.position) {
                            child.geometry.attributes.position.array.set(pos.array);
                            child.geometry.attributes.position.needsUpdate = true;
                            child.geometry.computeVertexNormals();
                        }
                    }
                });
                updateSelectionVisuals();
            });
            scene.add(transformControl);

            // Visual Helpers
            hoverMesh = new THREE.Mesh(new THREE.BufferGeometry(), new THREE.MeshBasicMaterial({ color: 0xffff00, side: THREE.DoubleSide, transparent: true, opacity: 0.5, depthTest: false }));
            hoverMesh.visible = false;
            scene.add(hoverMesh);

            selectionMesh = new THREE.Mesh(new THREE.BufferGeometry(), new THREE.MeshBasicMaterial({ color: 0x2563EB, side: THREE.DoubleSide, transparent: true, opacity: 0.6, depthTest: false }));
            selectionMesh.visible = false;
            scene.add(selectionMesh);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 2);
            dirLight.position.set(5, 10, 7.5);
            scene.add(dirLight);
            const fillLight = new THREE.DirectionalLight(0xffffff, 1);
            fillLight.position.set(-5, 0, -5);
            scene.add(fillLight);

            window.addEventListener('resize', onWindowResize, false);
            setupMouseEvents();
            setupCameraHotkeys();
            
            onWindowResize();
            animate();
            updateCursor();
        }

        function onWindowResize() {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
            
            // Sync Lasso Canvas Dimensions
            lassoCanvas.width = container.clientWidth;
            lassoCanvas.height = container.clientHeight;
        }

        function animate() {
            requestAnimationFrame(animate);
            if(controls.enabled) controls.update();
            renderer.render(scene, camera);
        }
        
        // Background Color
        bgColorPicker.addEventListener('input', (e) => {
            scene.background = new THREE.Color(e.target.value);
        });

        // --- Local Database (IndexedDB) ---
        let db;
        const request = indexedDB.open("ModderGLBProjects", 1);
        request.onupgradeneeded = (e) => {
            db = e.target.result;
            if(!db.objectStoreNames.contains("projects")) db.createObjectStore("projects", { keyPath: "id" });
        };
        request.onsuccess = (e) => { db = e.target.result; };

        document.getElementById('btn-save-project').addEventListener('click', () => {
            if(!currentModel || !currentGlbBuffer) { alert("Import a GLB first!"); return; }
            
            const state = [];
            currentModel.traverse((child) => {
                if (child.isMesh && child.userData.originalGeometry) {
                    state.push({
                        name: child.name,
                        uuid: child.uuid,
                        deletedFaces: Array.from(child.userData.deletedFaces),
                        selectedFaces: Array.from(child.userData.selectedFaces),
                        positions: Array.from(child.userData.originalGeometry.attributes.position.array),
                        matrix: child.matrixWorld.toArray()
                    });
                }
            });

            const proj = {
                id: Date.now(),
                name: originalFileName + " - " + new Date().toLocaleTimeString(),
                glb: currentGlbBuffer,
                state: state
            };

            const tx = db.transaction("projects", "readwrite");
            tx.objectStore("projects").put(proj);
            tx.oncomplete = () => { alert("Project Saved to Browser Storage!"); loadProjectsList(); };
        });

        function loadProjectsList() {
            if(!db) return;
            const list = document.getElementById('projects-list');
            list.innerHTML = '';
            
            const tx = db.transaction("projects", "readonly");
            const store = tx.objectStore("projects");
            store.openCursor().onsuccess = (e) => {
                const cursor = e.target.result;
                if(cursor) {
                    const p = cursor.value;
                    const div = document.createElement('div');
                    div.className = "flex justify-between items-center bg-gray-900 p-2 rounded";
                    div.innerHTML = `<span class="text-xs text-gray-300 truncate mr-2">${p.name}</span>
                        <div class="flex gap-1">
                            <button class="bg-blue-600 hover:bg-blue-500 text-white px-2 py-1 rounded text-[10px]" onclick="window.loadProj(${p.id})">Load</button>
                            <button class="bg-red-900 hover:bg-red-800 text-white px-2 py-1 rounded text-[10px]" onclick="window.delProj(${p.id})">Del</button>
                        </div>`;
                    list.appendChild(div);
                    cursor.continue();
                }
            };
        }

        window.delProj = (id) => {
            const tx = db.transaction("projects", "readwrite");
            tx.objectStore("projects").delete(id);
            tx.oncomplete = () => loadProjectsList();
        };

        window.loadProj = (id) => {
            const tx = db.transaction("projects", "readonly");
            tx.objectStore("projects").get(id).onsuccess = (e) => {
                const p = e.target.result;
                if(p) {
                    originalFileName = p.name.split(" - ")[0];
                    document.getElementById('filename-display').textContent = originalFileName;
                    document.getElementById('projects-modal').classList.add('hidden');
                    loadGLTF(p.glb, p.state);
                }
            };
        };


        // --- Upload Logic ---
        fileInput.addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (!file) return;

            originalFileName = file.name.replace(/\.[^/.]+$/, "");
            document.getElementById('filename-display').textContent = file.name;
            showLoading(true, "LOADING GLB...");

            const reader = new FileReader();
            reader.onload = function(e) { 
                currentGlbBuffer = e.target.result;
                loadGLTF(currentGlbBuffer); 
            };
            reader.readAsArrayBuffer(file);
        });

        function loadGLTF(arrayBuffer, savedState = null) {
            const loader = new GLTFLoader();
            currentGlbBuffer = arrayBuffer; // Cache in memory
            
            if (currentModel) {
                modelContainer.remove(currentModel);
                disableGizmo();
                currentModel.traverse((child) => {
                    if (child.isMesh) {
                        child.geometry.dispose();
                        if(Array.isArray(child.material)) child.material.forEach(m => m.dispose());
                        else if(child.material) child.material.dispose();
                    }
                });
            }

            loader.parse(arrayBuffer, '', (gltf) => {
                currentModel = gltf.scene;
                
                // If loaded from project, we will apply state. Wait for full setup.
                currentModel.traverse((child) => {
                    if (child.isMesh) {
                        if (child.material) {
                            child.material.side = THREE.DoubleSide;
                            child.material.wireframe = isWireframeActive;
                        }
                        
                        try {
                            let merged = BufferGeometryUtils.mergeVertices(child.geometry, 1e-4); 
                            merged.computeVertexNormals();
                            child.geometry = merged;
                        } catch(e) { console.warn("Error welding model vertices.", e); }
                        
                        child.userData.originalGeometry = child.geometry.clone();
                        child.userData.deletedFaces = new Set();
                        child.userData.selectedFaces = new Set();
                        child.userData.isHidden = false;
                        
                        buildAdjacencyList(child);
                    }
                });

                if(savedState) {
                    // Restore state
                    const toRemove = [];
                    currentModel.traverse((child) => {
                        if (child.isMesh) {
                            const stateMatch = savedState.find(s => s.name === child.name || s.uuid === child.uuid);
                            if(stateMatch) {
                                child.userData.deletedFaces = new Set(stateMatch.deletedFaces);
                                child.userData.selectedFaces = new Set(stateMatch.selectedFaces);
                                child.userData.originalGeometry.attributes.position.array.set(stateMatch.positions);
                                child.geometry.attributes.position.array.set(stateMatch.positions);
                                child.geometry.attributes.position.needsUpdate = true;
                                child.matrix.fromArray(stateMatch.matrix);
                                child.matrix.decompose(child.position, child.quaternion, child.scale);
                                
                                // Check if fully deleted
                                if(child.userData.deletedFaces.size === child.userData.originalGeometry.index.count/3) {
                                    toRemove.push(child);
                                }
                            }
                        }
                    });
                    toRemove.forEach(obj => obj.parent.remove(obj));
                }

                modelContainer.rotation.set(0, 0, 0);

                const box = new THREE.Box3().setFromObject(currentModel);
                const size = box.getSize(new THREE.Vector3());
                maxModelDimension = Math.max(size.x, size.y, size.z);
                const scale = 4 / maxModelDimension;
                currentModel.scale.set(scale, scale, scale);
                
                const boxScaled = new THREE.Box3().setFromObject(currentModel);
                const centerScaled = boxScaled.getCenter(new THREE.Vector3());
                currentModel.position.set(-centerScaled.x, -boxScaled.min.y, -centerScaled.z);

                modelContainer.add(currentModel);
                resetCamera();

                if(savedState) resetGeometryForErasing();

                buildHierarchyTree();
                updateTargetUI();
                recalculateBaseStats();
                clearHistory();
                updateSelectionVisuals();
                
                btnConvert.disabled = false;
                btnConvert.classList.remove('bg-gray-800', 'text-gray-500', 'cursor-not-allowed');
                btnConvert.classList.add('bg-blue-600', 'text-white', 'hover:bg-blue-500', 'border-blue-500');

                btnConvertSel.disabled = false;
                btnConvertSel.classList.remove('bg-[#030712]', 'text-gray-500', 'cursor-not-allowed');
                btnConvertSel.classList.add('text-gray-300');

                showLoading(false);
            }, () => { alert("Error loading GLB file."); showLoading(false); });
        }
        
        function buildAdjacencyList(mesh) {
            const index = mesh.userData.originalGeometry.index;
            const adjacency = new Map();
            for(let i=0; i<index.count; i+=3) {
                const faceIdx = i/3;
                [index.getX(i), index.getX(i+1), index.getX(i+2)].forEach(v => {
                    if(!adjacency.has(v)) adjacency.set(v, []);
                    adjacency.get(v).push(faceIdx);
                });
            }
            mesh.userData.adjacency = adjacency;
        }

        // --- Hierarchy Tree Logic ---
        function buildHierarchyTree() {
            hierarchyList.innerHTML = '';
            
            const eyeOpen = `<svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path></svg>`;
            const eyeClosed = `<svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.88 9.88l-3.29-3.29m7.532 7.532l3.29 3.29M3 3l3.59 3.59m0 0A9.953 9.953 0 0112 5c4.478 0 8.268 2.943 9.543 7a10.025 10.025 0 01-4.132 5.411m0 0L21 21"></path></svg>`;

            let partCount = 0;

            currentModel.traverse((child) => {
                if (child.isMesh) {
                    // Do not list empty meshes
                    if(child.userData.deletedFaces.size >= child.userData.originalGeometry.index.count/3) return;

                    partCount++;
                    const name = child.name || `Object_${partCount}`;
                    
                    const div = document.createElement('div');
                    div.className = 'tree-item';
                    
                    if (child.userData.selectedFaces && child.userData.selectedFaces.size > 0) {
                        div.classList.add('selected');
                    }
                    
                    const nameSpan = document.createElement('span');
                    nameSpan.className = 'tree-item-name';
                    nameSpan.textContent = name;
                    
                    nameSpan.addEventListener('click', (e) => {
                        saveHistoryState();
                        if (!e.shiftKey) {
                            currentModel.traverse(c => { if(c.isMesh) c.userData.selectedFaces.clear(); });
                        }
                        const indexCount = child.userData.originalGeometry.index.count;
                        for(let i = 0; i < indexCount; i+=3) {
                            const faceIdx = i / 3;
                            if (!child.userData.deletedFaces.has(faceIdx)) child.userData.selectedFaces.add(faceIdx);
                        }
                        updateSelectionVisuals();
                        buildHierarchyTree();
                        activateGizmoIfNeeded();
                    });

                    const visSpan = document.createElement('span');
                    visSpan.className = 'visibility-toggle';
                    visSpan.innerHTML = child.userData.isHidden ? eyeClosed : eyeOpen;
                    if (child.userData.isHidden) visSpan.classList.add('visibility-hidden');
                    
                    visSpan.addEventListener('click', () => {
                        child.userData.isHidden = !child.userData.isHidden;
                        child.visible = !child.userData.isHidden;
                        
                        visSpan.innerHTML = child.userData.isHidden ? eyeClosed : eyeOpen;
                        if (child.userData.isHidden) visSpan.classList.add('visibility-hidden');
                        else visSpan.classList.remove('visibility-hidden');
                        
                        recalculateBaseStats();
                        updateLiveStats();
                    });

                    div.appendChild(nameSpan);
                    div.appendChild(visSpan);
                    hierarchyList.appendChild(div);
                }
            });
        }

        // --- Tools Logic (V, M, L, W) ---
        function setTool(toolName) {
            currentTool = toolName;
            Object.values(toolBtns).forEach(btn => btn.classList.remove('active'));
            toolBtns[toolName].classList.add('active');
            updateCursor();
            controls.enabled = (toolName === 'select' || toolName === 'wand');
            updateStatusBar();
        }
        
        function updateCursor() {
            container.className = 'flex-grow w-full h-full outline-none';
            if(currentTool === 'lasso') container.classList.add('cursor-lasso');
            else if(currentTool === 'wand') container.classList.add('cursor-wand');
            else container.classList.add('cursor-select');
        }

        function updateStatusBar() {
            let txt = '';
            if (currentTool === 'select') txt = '<strong class="text-blue-400">V</strong>: Select | <strong class="text-blue-400">Shift+Click</strong>: Add to selection';
            if (currentTool === 'box') txt = '<strong class="text-blue-400">M</strong>: Marquee Box | <strong class="text-blue-400">Drag</strong> to select multiple elements';
            if (currentTool === 'lasso') txt = '<strong class="text-blue-400">L</strong>: Lasso Freehand | <strong class="text-blue-400">Draw</strong> outline to select region';
            if (currentTool === 'wand') txt = '<strong class="text-blue-400">W</strong>: Magic Wand | <strong class="text-blue-400">Click</strong> to select all linked faces instantly';
            statusText.innerHTML = txt;
        }

        Object.keys(toolBtns).forEach(key => {
            toolBtns[key].addEventListener('click', () => setTool(key));
        });

        // Keyboard Shortcuts
        window.addEventListener('keydown', (e) => {
            if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') return;
            const key = e.key.toLowerCase();
            if (key === 'v') setTool('select');
            if (key === 'm') setTool('box');
            if (key === 'l') setTool('lasso');
            if (key === 'w') setTool('wand');
        });

        // --- Modding Tools (Object Level) ---
        btnObjMirror.addEventListener('click', () => {
            if(!currentModel) return;
            saveHistoryState();
            let mirroredAny = false;
            const newMeshesToAttach = [];

            currentModel.traverse((child) => {
                if (child.isMesh && child.userData.selectedFaces && child.userData.selectedFaces.size > 0 && !child.userData.isHidden) {
                    const newGeom = child.userData.originalGeometry.clone();
                    const pos = newGeom.attributes.position;
                    for (let i = 0; i < pos.count; i++) pos.setX(i, -pos.getX(i));
                    
                    const index = newGeom.index;
                    for (let i = 0; i < index.count; i += 3) {
                        const a = index.getX(i);
                        index.setX(i, index.getX(i + 2));
                        index.setX(i + 2, a);
                    }
                    newGeom.computeVertexNormals();

                    const newMesh = new THREE.Mesh(newGeom, child.material);
                    newMesh.name = (child.name || "Part") + "_Mirrored";
                    newMesh.position.set(-child.position.x, child.position.y, child.position.z);
                    
                    const euler = new THREE.Euler().setFromQuaternion(child.quaternion);
                    euler.y = -euler.y; euler.z = -euler.z;
                    newMesh.quaternion.setFromEuler(euler);
                    newMesh.scale.copy(child.scale);

                    newMesh.userData.originalGeometry = newGeom;
                    newMesh.userData.deletedFaces = new Set(child.userData.deletedFaces);
                    newMesh.userData.selectedFaces = new Set();
                    newMesh.userData.isHidden = false;
                    buildAdjacencyList(newMesh);

                    newMeshesToAttach.push({parent: child.parent, mesh: newMesh});
                    mirroredAny = true;
                }
            });

            if(mirroredAny) {
                newMeshesToAttach.forEach(item => item.parent.add(item.mesh));
                disableGizmo();
                resetGeometryForErasing();
                recalculateBaseStats();
                buildHierarchyTree();
            } else {
                historyStack.pop();
            }
        });

        btnObjCenter.addEventListener('click', () => {
            if(!currentModel) return;
            saveHistoryState();
            let centeredAny = false;

            currentModel.traverse((child) => {
                if (child.isMesh && child.userData.selectedFaces && child.userData.selectedFaces.size > 0 && !child.userData.isHidden) {
                    const geom = child.userData.originalGeometry;
                    geom.computeBoundingBox();
                    const center = new THREE.Vector3();
                    geom.boundingBox.getCenter(center);

                    geom.translate(-center.x, -center.y, -center.z);
                    child.position.add(center.applyQuaternion(child.quaternion).multiply(child.scale));
                    child.updateMatrixWorld(true);

                    if (child.geometry.attributes.position) {
                        child.geometry.attributes.position.array.set(geom.attributes.position.array);
                        child.geometry.attributes.position.needsUpdate = true;
                    }
                    centeredAny = true;
                }
            });

            if (centeredAny) {
                disableGizmo();
                updateSelectionVisuals();
                activateGizmoIfNeeded();
            } else {
                historyStack.pop();
            }
        });

        // --- Wireframe & Camera ---
        btnWireframe.addEventListener('click', () => {
            isWireframeActive = !isWireframeActive;
            btnWireframe.classList.toggle('text-blue-400', isWireframeActive);
            btnWireframe.classList.toggle('text-white', !isWireframeActive);
            if (currentModel) {
                currentModel.traverse(c => {
                    if (c.isMesh && c.material) c.material.wireframe = isWireframeActive;
                });
            }
        });

        function resetCamera() {
            camera.position.set(4, 3, 5);
            controls.target.set(0, 2, 0);
            controls.update();
        }

        function setupCameraHotkeys() {
            window.addEventListener('keydown', (e) => {
                if (document.activeElement.tagName === 'INPUT') return;
                if (!currentModel) return;

                const dist = 5; 
                const target = new THREE.Vector3(0, 2, 0);

                switch(e.code) {
                    case 'Numpad7': case 'Digit7': camera.position.set(0, dist + 2, 0); break; // Top
                    case 'Numpad9': case 'Digit9': camera.position.set(0, -dist + 2, 0); break; // Bottom
                    case 'Numpad1': case 'Digit1': camera.position.set(0, 2, dist); break; // Front
                    case 'Numpad3': case 'Digit3': camera.position.set(dist, 2, 0); break; // Right
                    case 'KeyZ': 
                        if (e.ctrlKey || e.metaKey) {
                            undoLastAction();
                            e.preventDefault();
                        }
                        break;
                    case 'Delete':
                    case 'Backspace':
                        deleteSelectedFaces();
                        e.preventDefault();
                        break;
                    default: return; 
                }
                
                if (['Numpad7','Numpad9','Numpad1','Numpad3','Digit7','Digit9','Digit1','Digit3'].includes(e.code)) {
                    controls.target.copy(target);
                    controls.update();
                }
            });
        }

        // --- Limits & Stats ---
        targetTypeSelect.addEventListener('change', () => {
            if(!currentModel) return;
            
            // Full poly visual correction fix
            if (targetTypeSelect.value === 'full') {
                resetGeometryForErasing();
            }
            
            updateTargetUI();
            updateLiveStats();
        });

        function updateTargetUI() {
            const target = targetTypeSelect.value;
            const maxPolys = LIMITS[target].polys;
            
            simplifySlider.max = baseStats.triangles;
            
            if (target === 'full') {
                decimateBlock.classList.add('opacity-50', 'pointer-events-none');
                simplifySlider.value = baseStats.triangles;
                targetVal.textContent = "Unlimited";
                btnApplyDecimate.disabled = true;
            } else {
                decimateBlock.classList.remove('opacity-50', 'pointer-events-none');
                const defaultTarget = Math.min(baseStats.triangles, maxPolys);
                simplifySlider.value = defaultTarget;
                targetVal.textContent = defaultTarget.toLocaleString();
                btnApplyDecimate.disabled = false;
            }
        }

        function recalculateBaseStats() {
            baseStats = { vertices: 0, triangles: 0 };
            if(!currentModel) return;
            currentModel.traverse((child) => {
                if (child.isMesh && child.userData.originalGeometry && !child.userData.isHidden) {
                    const idx = child.userData.originalGeometry.index;
                    const deleted = child.userData.deletedFaces;
                    
                    const activeIndices = new Set();
                    let activeFaces = 0;
                    for(let i=0; i<idx.count; i+=3) {
                        const faceIdx = i / 3;
                        if(!deleted.has(faceIdx)) {
                            activeFaces++;
                            activeIndices.add(idx.getX(i));
                            activeIndices.add(idx.getX(i+1));
                            activeIndices.add(idx.getX(i+2));
                        }
                    }
                    baseStats.triangles += activeFaces;
                    baseStats.vertices += activeIndices.size;
                }
            });
            updateTargetUI();
        }

        function updateLiveStats() {
            modelStats = { vertices: 0, triangles: 0 };
            if(!currentModel) return;
            currentModel.traverse((child) => {
                if (child.isMesh && child.geometry.index && !child.userData.isHidden) {
                    modelStats.triangles += child.geometry.index.count / 3;
                    const idx = child.geometry.index;
                    const activeSet = new Set();
                    for(let i=0; i<idx.count; i++) activeSet.add(idx.getX(i));
                    modelStats.vertices += activeSet.size;
                }
            });

            statVerts.textContent = modelStats.vertices.toLocaleString();
            statTris.textContent = Math.floor(modelStats.triangles).toLocaleString();
            
            const target = targetTypeSelect.value;
            if(modelStats.vertices > LIMITS[target].verts) {
                vertWarning.classList.remove('hidden');
                statVerts.classList.add('text-red-400'); statVerts.classList.remove('text-gray-300');
            } else {
                vertWarning.classList.add('hidden');
                statVerts.classList.remove('text-red-400'); statVerts.classList.add('text-gray-300');
            }
            if(modelStats.triangles > LIMITS[target].polys) {
                polyWarning.classList.remove('hidden');
                statTris.classList.add('text-red-400'); statTris.classList.remove('text-gray-300');
            } else {
                polyWarning.classList.add('hidden');
                statTris.classList.remove('text-red-400'); statTris.classList.add('text-gray-300');
            }
        }

        // --- Undo System ---
        function saveHistoryState() {
            if (!currentModel) return;
            const state = [];
            currentModel.traverse((child) => {
                if (child.isMesh && child.userData.originalGeometry) {
                    state.push({
                        uuid: child.uuid,
                        deletedFaces: new Set(child.userData.deletedFaces),
                        selectedFaces: new Set(child.userData.selectedFaces),
                        positions: new Float32Array(child.userData.originalGeometry.attributes.position.array)
                    });
                }
            });
            historyStack.push(state);
            if (historyStack.length > MAX_HISTORY) historyStack.shift();
            updateUndoUI();
        }

        function undoLastAction() {
            if (historyStack.length === 0 || !currentModel) return;
            
            disableGizmo();
            
            const lastState = historyStack.pop();
            const uuidsInState = new Set(lastState.map(s => s.uuid));
            
            const objectsToRemove = [];
            currentModel.traverse((child) => {
                if (child.isMesh && !uuidsInState.has(child.uuid)) objectsToRemove.push(child);
            });
            objectsToRemove.forEach(obj => obj.parent.remove(obj));

            currentModel.traverse((child) => {
                if (child.isMesh && child.userData.originalGeometry) {
                    const savedState = lastState.find(s => s.uuid === child.uuid);
                    if (savedState) {
                        child.userData.deletedFaces = new Set(savedState.deletedFaces);
                        child.userData.selectedFaces = new Set(savedState.selectedFaces);
                        
                        const posAttr = child.userData.originalGeometry.attributes.position;
                        posAttr.array.set(savedState.positions);
                        posAttr.needsUpdate = true;

                        if (child.geometry.attributes.position) {
                            child.geometry.attributes.position.array.set(savedState.positions);
                            child.geometry.attributes.position.needsUpdate = true;
                            child.geometry.computeVertexNormals();
                        }
                    }
                }
            });
            
            buildHierarchyTree(); 
            updateSelectionVisuals();
            resetGeometryForErasing();
            recalculateBaseStats();
            updateUndoUI();
            activateGizmoIfNeeded();
        }

        function clearHistory() {
            historyStack = [];
            updateUndoUI();
        }

        function updateUndoUI() {
            if (historyStack.length > 0) {
                btnUndo.classList.remove('opacity-50', 'cursor-not-allowed');
            } else {
                btnUndo.classList.add('opacity-50', 'cursor-not-allowed');
            }
        }
        
        btnUndo.addEventListener('click', undoLastAction);

        // --- Gizmo Mode ---
        function setGizmoMode(mode) {
            currentGizmoMode = mode;
            transformControl.setMode(mode);
            document.getElementById('gizmo-translate').classList.toggle('active', mode === 'translate');
            document.getElementById('gizmo-rotate').classList.toggle('active', mode === 'rotate');
            document.getElementById('gizmo-scale').classList.toggle('active', mode === 'scale');
            
            let txt = '';
            if (mode === 'translate') txt = "Translate / Move Selection Handles";
            if (mode === 'rotate') txt = "Rotate Selection Handles";
            if (mode === 'scale') txt = "Scale Selection Handles";
            statusText.innerHTML = `<span class='text-emerald-400'>${txt}</span>`;
        }
        document.getElementById('gizmo-translate').addEventListener('click', () => setGizmoMode('translate'));
        document.getElementById('gizmo-rotate').addEventListener('click', () => setGizmoMode('rotate'));
        document.getElementById('gizmo-scale').addEventListener('click', () => setGizmoMode('scale'));

        function activateGizmoIfNeeded() {
            let hasSelection = false;
            let center = new THREE.Vector3();
            let count = 0;
            
            if(!currentModel) return;
            currentModel.traverse((child) => {
                if (child.isMesh && child.userData.selectedFaces && child.userData.selectedFaces.size > 0 && !child.userData.isHidden) {
                    hasSelection = true;
                    const pos = child.userData.originalGeometry.attributes.position;
                    const index = child.userData.originalGeometry.index;
                    const matrix = child.matrixWorld;
                    
                    child.userData.selectedFaces.forEach(faceIdx => {
                        const a = index.getX(faceIdx * 3);
                        const v = new THREE.Vector3().fromBufferAttribute(pos, a).applyMatrix4(matrix);
                        center.add(v);
                        count++;
                    });
                }
            });

            if (hasSelection) {
                center.divideScalar(count);
                transformProxy.position.copy(center);
                transformProxy.quaternion.copy(modelContainer.quaternion); 
                transformProxy.scale.set(1, 1, 1);
                transformControl.attach(transformProxy);
            } else {
                disableGizmo();
            }
        }

        function disableGizmo() {
            if (transformControl.object) {
                transformControl.detach();
                recalculateBaseStats();
            }
        }

        // --- Mouse System & Selection Tools ---
        function pointInPolygon(point, vs) {
            var x = point[0], y = point[1];
            var inside = false;
            for (var i = 0, j = vs.length - 1; i < vs.length; j = i++) {
                var xi = vs[i][0], yi = vs[i][1];
                var xj = vs[j][0], yj = vs[j][1];
                var intersect = ((yi > y) != (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        function setupMouseEvents() {
            container.addEventListener('pointerdown', (e) => {
                if (isGizmoDragging || transformControl.axis !== null) return; 

                const rect = container.getBoundingClientRect();
                pointerDownPos = { x: e.clientX, y: e.clientY };
                
                if (currentTool === 'box') {
                    isMarqueeSelecting = true;
                    controls.enabled = false;
                    marqueeStart.set(e.clientX - rect.left, e.clientY - rect.top);
                    marqueeEnd.copy(marqueeStart);
                    updateSelectionBoxUI();
                } else if (currentTool === 'lasso') {
                    isDragging = true;
                    controls.enabled = false;
                    lassoPoints = [[e.clientX - rect.left, e.clientY - rect.top]];
                    drawLasso();
                }
            });

            container.addEventListener('pointermove', (e) => {
                if (isGizmoDragging) return;

                const rect = container.getBoundingClientRect();
                mouse.set(((e.clientX - rect.left) / rect.width) * 2 - 1, -((e.clientY - rect.top) / rect.height) * 2 + 1);
                raycaster.setFromCamera(mouse, camera);

                if (isMarqueeSelecting) {
                    marqueeEnd.set(e.clientX - rect.left, e.clientY - rect.top);
                    updateSelectionBoxUI();
                    return;
                }

                if (currentTool === 'lasso' && isDragging) {
                    lassoPoints.push([e.clientX - rect.left, e.clientY - rect.top]);
                    drawLasso();
                    return;
                }

                if ((currentTool === 'select' || currentTool === 'wand') && transformControl.axis === null) {
                    const intersects = raycaster.intersectObject(currentModel, true);
                    const visibleIntersects = intersects.filter(hit => !hit.object.userData.isHidden);
                    updateHoverVisual(visibleIntersects.length > 0 ? visibleIntersects[0] : null);
                } else {
                    hoverMesh.visible = false;
                }
            });

            container.addEventListener('pointerup', (e) => {
                if(isGizmoDragging) return;
                
                if (currentTool === 'box' && isMarqueeSelecting) {
                    isMarqueeSelecting = false;
                    selectionBox.classList.add('hidden');
                    controls.enabled = false;
                    
                    if (marqueeStart.distanceTo(marqueeEnd) > 5) {
                        saveHistoryState();
                        performMarqueeSelection(e.shiftKey);
                    }
                } else if (currentTool === 'lasso' && isDragging) {
                    isDragging = false;
                    lassoCtx.clearRect(0, 0, lassoCanvas.width, lassoCanvas.height);
                    controls.enabled = false;
                    
                    if (lassoPoints.length > 2) {
                        saveHistoryState();
                        performLassoSelection(e.shiftKey);
                    }
                } else if (currentTool === 'select' || currentTool === 'wand') {
                    if (Math.abs(e.clientX - pointerDownPos.x) < 5 && Math.abs(e.clientY - pointerDownPos.y) < 5) {
                        if(transformControl.axis === null) {
                            saveHistoryState();
                            handleSelectClick(e);
                        }
                    }
                }
                
                if(currentTool === 'select' || currentTool === 'wand') controls.enabled = true;
            });
        }
        
        function drawLasso() {
            lassoCtx.clearRect(0, 0, lassoCanvas.width, lassoCanvas.height);
            if(lassoPoints.length < 2) return;
            
            lassoCtx.beginPath();
            lassoCtx.moveTo(lassoPoints[0][0], lassoPoints[0][1]);
            for(let i=1; i<lassoPoints.length; i++) {
                lassoCtx.lineTo(lassoPoints[i][0], lassoPoints[i][1]);
            }
            lassoCtx.strokeStyle = '#60A5FA';
            lassoCtx.lineWidth = 1.5;
            lassoCtx.stroke();
            
            lassoCtx.fillStyle = 'rgba(59, 130, 246, 0.2)';
            lassoCtx.fill();
        }

        function updateSelectionBoxUI() {
            selectionBox.classList.remove('hidden');
            const left = Math.min(marqueeStart.x, marqueeEnd.x);
            const top = Math.min(marqueeStart.y, marqueeEnd.y);
            const width = Math.abs(marqueeStart.x - marqueeEnd.x);
            const height = Math.abs(marqueeStart.y - marqueeEnd.y);

            selectionBox.style.left = left + 'px';
            selectionBox.style.top = top + 'px';
            selectionBox.style.width = width + 'px';
            selectionBox.style.height = height + 'px';
        }

        function performMarqueeSelection(addMode) {
            if (!currentModel) return;
            const rect = container.getBoundingClientRect();
            const minX = Math.min(marqueeStart.x, marqueeEnd.x) / rect.width * 2 - 1;
            const maxX = Math.max(marqueeStart.x, marqueeEnd.x) / rect.width * 2 - 1;
            const minY = -(Math.max(marqueeStart.y, marqueeEnd.y) / rect.height * 2 - 1);
            const maxY = -(Math.min(marqueeStart.y, marqueeEnd.y) / rect.height * 2 - 1);

            if(!addMode) currentModel.traverse(c => { if(c.isMesh) c.userData.selectedFaces.clear(); });

            currentModel.traverse((child) => {
                if (child.isMesh && child.userData.originalGeometry && !child.userData.isHidden) {
                    const pos = child.userData.originalGeometry.attributes.position;
                    const index = child.userData.originalGeometry.index;
                    const matrix = child.matrixWorld;
                    const deleted = child.userData.deletedFaces;
                    const vA = new THREE.Vector3(), vB = new THREE.Vector3(), vC = new THREE.Vector3();

                    for (let i = 0; i < index.count; i += 3) {
                        const faceIdx = i / 3;
                        if (deleted.has(faceIdx)) continue;

                        vA.fromBufferAttribute(pos, index.getX(i)).applyMatrix4(matrix).project(camera);
                        vB.fromBufferAttribute(pos, index.getX(i+1)).applyMatrix4(matrix).project(camera);
                        vC.fromBufferAttribute(pos, index.getX(i+2)).applyMatrix4(matrix).project(camera);

                        const isInside = (v) => v.x >= minX && v.x <= maxX && v.y >= minY && v.y <= maxY && v.z <= 1;

                        if (isInside(vA) || isInside(vB) || isInside(vC)) {
                            child.userData.selectedFaces.add(faceIdx);
                        }
                    }
                }
            });

            updateSelectionVisuals();
            buildHierarchyTree();
            activateGizmoIfNeeded();
        }
        
        function performLassoSelection(addMode) {
            if (!currentModel) return;
            const rect = container.getBoundingClientRect();
            if(!addMode) currentModel.traverse(c => { if(c.isMesh) c.userData.selectedFaces.clear(); });

            currentModel.traverse((child) => {
                if (child.isMesh && child.userData.originalGeometry && !child.userData.isHidden) {
                    const pos = child.userData.originalGeometry.attributes.position;
                    const index = child.userData.originalGeometry.index;
                    const matrix = child.matrixWorld;
                    const deleted = child.userData.deletedFaces;
                    const vA = new THREE.Vector3();

                    for (let i = 0; i < index.count; i += 3) {
                        const faceIdx = i / 3;
                        if (deleted.has(faceIdx)) continue;
                        
                        const idxA = index.getX(i), idxB = index.getX(i+1), idxC = index.getX(i+2);
                        vA.fromBufferAttribute(pos, idxA).add(new THREE.Vector3().fromBufferAttribute(pos, idxB)).add(new THREE.Vector3().fromBufferAttribute(pos, idxC)).divideScalar(3);
                        vA.applyMatrix4(matrix).project(camera);
                        
                        const px = (vA.x + 1) / 2 * rect.width;
                        const py = -(vA.y - 1) / 2 * rect.height;

                        if (vA.z <= 1 && pointInPolygon([px, py], lassoPoints)) {
                            child.userData.selectedFaces.add(faceIdx);
                        }
                    }
                }
            });

            updateSelectionVisuals();
            buildHierarchyTree();
            activateGizmoIfNeeded();
        }

        function updateHoverVisual(hit) {
            if (!hit || hit.object.userData.isHidden) { hoverMesh.visible = false; return; }
            const child = hit.object;
            const faceIdx = hit.faceIndex;
            if (faceIdx === undefined) return;
            
            const origGeom = child.userData.originalGeometry;
            if (!origGeom || child.userData.deletedFaces.has(faceIdx)) return;
            
            const pos = origGeom.attributes.position;
            const index = origGeom.index;
            const a = index.getX(faceIdx * 3), b = index.getX(faceIdx * 3 + 1), c = index.getX(faceIdx * 3 + 2);
            
            const vA = new THREE.Vector3().fromBufferAttribute(pos, a).applyMatrix4(child.matrixWorld);
            const vB = new THREE.Vector3().fromBufferAttribute(pos, b).applyMatrix4(child.matrixWorld);
            const vC = new THREE.Vector3().fromBufferAttribute(pos, c).applyMatrix4(child.matrixWorld);
            
            hoverMesh.geometry.setAttribute('position', new THREE.Float32BufferAttribute([vA.x,vA.y,vA.z, vB.x,vB.y,vB.z, vC.x,vC.y,vC.z], 3));
            hoverMesh.visible = true;
        }

        function updateSelectionVisuals() {
            const positions = [];
            currentModel.traverse((child) => {
                if (child.isMesh && child.userData.originalGeometry && child.userData.selectedFaces && !child.userData.isHidden) {
                    const pos = child.userData.originalGeometry.attributes.position;
                    const index = child.userData.originalGeometry.index;
                    const matrix = child.matrixWorld;
                    child.userData.selectedFaces.forEach(faceIdx => {
                        const a = index.getX(faceIdx * 3), b = index.getX(faceIdx * 3 + 1), c = index.getX(faceIdx * 3 + 2);
                        const vA = new THREE.Vector3().fromBufferAttribute(pos, a).applyMatrix4(matrix);
                        const vB = new THREE.Vector3().fromBufferAttribute(pos, b).applyMatrix4(matrix);
                        const vC = new THREE.Vector3().fromBufferAttribute(pos, c).applyMatrix4(matrix);
                        positions.push(vA.x, vA.y, vA.z, vB.x, vB.y, vB.z, vC.x, vC.y, vC.z);
                    });
                }
            });
            if (positions.length > 0) {
                selectionMesh.geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                selectionMesh.visible = true;
            } else selectionMesh.visible = false;
        }

        function handleSelectClick(e) {
            const intersects = raycaster.intersectObject(currentModel, true);
            const visibleIntersects = intersects.filter(hit => !hit.object.userData.isHidden);

            if (visibleIntersects.length > 0) {
                const child = visibleIntersects[0].object;
                const hitFaceIdx = visibleIntersects[0].faceIndex;
                
                if (hitFaceIdx !== undefined && !child.userData.deletedFaces.has(hitFaceIdx)) {
                    if (!e.shiftKey) currentModel.traverse(c => { if(c.isMesh) c.userData.selectedFaces.clear(); });
                    
                    if (currentTool === 'wand') {
                        // Magic Wand BFS
                        const queue = [hitFaceIdx];
                        const visited = new Set();
                        const adj = child.userData.adjacency;
                        const index = child.userData.originalGeometry.index;
                        
                        while(queue.length > 0) {
                            const curr = queue.shift();
                            if(visited.has(curr) || child.userData.deletedFaces.has(curr)) continue;
                            
                            visited.add(curr);
                            child.userData.selectedFaces.add(curr);
                            
                            // Find neighbors
                            [index.getX(curr*3), index.getX(curr*3+1), index.getX(curr*3+2)].forEach(v => {
                                if(adj.has(v)) {
                                    adj.get(v).forEach(neighbor => {
                                        if(!visited.has(neighbor)) queue.push(neighbor);
                                    });
                                }
                            });
                        }
                    } else {
                        // Single Select
                        if (e.shiftKey && child.userData.selectedFaces.has(hitFaceIdx)) child.userData.selectedFaces.delete(hitFaceIdx);
                        else child.userData.selectedFaces.add(hitFaceIdx);
                    }
                    
                    updateSelectionVisuals();
                    buildHierarchyTree();
                    activateGizmoIfNeeded();
                }
            } else {
                if (!e.shiftKey) {
                    currentModel.traverse(c => { if(c.isMesh) c.userData.selectedFaces.clear(); });
                    updateSelectionVisuals();
                    disableGizmo();
                    buildHierarchyTree();
                }
            }
        }

        // DELETING LOGIC WITH OUTLINER SYNC
        function deleteSelectedFaces() {
            let deletedAny = false;
            saveHistoryState();
            disableGizmo();
            
            const toRemove = [];

            currentModel.traverse((child) => {
                if (child.isMesh && child.userData.selectedFaces && child.userData.selectedFaces.size > 0 && !child.userData.isHidden) {
                    child.userData.selectedFaces.forEach(faceIdx => child.userData.deletedFaces.add(faceIdx));
                    child.userData.selectedFaces.clear();
                    deletedAny = true;
                    
                    // Outliner Sync: If entirely deleted, flag for removal
                    const totalFaces = child.userData.originalGeometry.index.count / 3;
                    if(child.userData.deletedFaces.size >= totalFaces) {
                        toRemove.push(child);
                    }
                }
            });
            
            // Remove from Scene
            toRemove.forEach(obj => {
                if (obj.parent) obj.parent.remove(obj);
            });

            if (deletedAny) {
                updateSelectionVisuals();
                hoverMesh.visible = false;
                resetGeometryForErasing();
                recalculateBaseStats();
                buildHierarchyTree(); // Update UI
            } else {
                historyStack.pop();
            }
        }

        // Extract & Duplicate Tools
        function performExtractionOrDuplication(isExtract) {
            saveHistoryState();
            let createdAny = false;
            const newMeshesToAttach = [];
            const toRemove = [];

            currentModel.traverse((child) => {
                if (child.isMesh && child.userData.selectedFaces && child.userData.selectedFaces.size > 0 && !child.userData.isHidden) {
                    const origGeom = child.userData.originalGeometry;
                    const pos = origGeom.attributes.position;
                    const norm = origGeom.attributes.normal;
                    const index = origGeom.index;

                    const newIndices = [];
                    const map = new Map();
                    let newIdx = 0;
                    const newPos = [], newNorm = [];

                    child.userData.selectedFaces.forEach(faceIdx => {
                        const a = index.getX(faceIdx * 3), b = index.getX(faceIdx * 3 + 1), c = index.getX(faceIdx * 3 + 2);
                        [a, b, c].forEach(idx => {
                            if(!map.has(idx)) {
                                map.set(idx, newIdx++);
                                newPos.push(pos.getX(idx), pos.getY(idx), pos.getZ(idx));
                                if(norm) newNorm.push(norm.getX(idx), norm.getY(idx), norm.getZ(idx));
                            }
                        });
                        newIndices.push(map.get(a), map.get(b), map.get(c));
                    });

                    const newGeom = new THREE.BufferGeometry();
                    newGeom.setAttribute('position', new THREE.Float32BufferAttribute(newPos, 3));
                    if(norm) newGeom.setAttribute('normal', new THREE.Float32BufferAttribute(newNorm, 3));
                    newGeom.setIndex(newIndices);

                    const newMesh = new THREE.Mesh(newGeom, child.material);
                    newMesh.name = (child.name || "Part") + (isExtract ? "_Extracted" : "_Duplicate");
                    newMesh.position.copy(child.position);
                    newMesh.quaternion.copy(child.quaternion);
                    newMesh.scale.copy(child.scale);

                    newMesh.userData.originalGeometry = newGeom.clone();
                    newMesh.userData.deletedFaces = new Set();
                    newMesh.userData.selectedFaces = new Set();
                    newMesh.userData.isHidden = false;
                    buildAdjacencyList(newMesh);

                    newMeshesToAttach.push({parent: child.parent, mesh: newMesh});

                    if (isExtract) {
                        child.userData.selectedFaces.forEach(faceIdx => child.userData.deletedFaces.add(faceIdx));
                        
                        // Outliner Sync extraction
                        if(child.userData.deletedFaces.size >= child.userData.originalGeometry.index.count/3) {
                            toRemove.push(child);
                        }
                    }
                    child.userData.selectedFaces.clear();
                    createdAny = true;
                }
            });

            if (createdAny) {
                newMeshesToAttach.forEach(item => item.parent.add(item.mesh));
                toRemove.forEach(obj => { if(obj.parent) obj.parent.remove(obj); });
                disableGizmo();
                updateSelectionVisuals();
                resetGeometryForErasing();
                recalculateBaseStats();
                buildHierarchyTree();
            } else {
                historyStack.pop();
                alert("Selecione polígonos primeiro.");
            }
        }

        btnActionExtract.addEventListener('click', () => performExtractionOrDuplication(true));
        btnActionDuplicate.addEventListener('click', () => performExtractionOrDuplication(false));

        btnClearSel.addEventListener('click', () => {
            saveHistoryState();
            disableGizmo();
            currentModel.traverse((child) => { if (child.isMesh && child.userData.selectedFaces) child.userData.selectedFaces.clear(); });
            updateSelectionVisuals();
            buildHierarchyTree();
        });

        // --- Decimation (Manual Apply) ---
        function getCleanBaseGeometry(child) {
            const orig = child.userData.originalGeometry;
            const deleted = child.userData.deletedFaces;
            let cleanGeom;
            if (!deleted || deleted.size === 0) {
                 cleanGeom = orig.clone();
            } else {
                const pos = orig.attributes.position;
                const norm = orig.attributes.normal;
                const index = orig.index;
                const map = new Map();
                let newIdx = 0;
                const newPos = [], newNorm = [], newIndices = [];
                
                for(let i=0; i<index.count; i+=3) {
                    if(!deleted.has(i / 3)) {
                        const a = index.getX(i), b = index.getX(i+1), c = index.getX(i+2);
                        [a, b, c].forEach(idx => {
                            if(!map.has(idx)) {
                                map.set(idx, newIdx++);
                                newPos.push(pos.getX(idx), pos.getY(idx), pos.getZ(idx));
                                if(norm) newNorm.push(norm.getX(idx), norm.getY(idx), norm.getZ(idx));
                            }
                        });
                        newIndices.push(map.get(a), map.get(b), map.get(c));
                    }
                }
                cleanGeom = new THREE.BufferGeometry();
                cleanGeom.setAttribute('position', new THREE.Float32BufferAttribute(newPos, 3));
                if(norm) cleanGeom.setAttribute('normal', new THREE.Float32BufferAttribute(newNorm, 3));
                cleanGeom.setIndex(newIndices);
            }
            try {
                cleanGeom = BufferGeometryUtils.mergeVertices(cleanGeom, 1e-4);
                cleanGeom.computeVertexNormals();
            } catch (e) { }
            return cleanGeom;
        }

        function resetGeometryForErasing() {
            if(!currentModel) return;
            currentModel.traverse((child) => {
                if(child.isMesh && child.userData.originalGeometry) {
                    const origGeom = child.userData.originalGeometry.clone();
                    const origIndex = origGeom.index;
                    const deleted = child.userData.deletedFaces;
                    const newIndices = [];
                    for (let i = 0; i < origIndex.count; i += 3) {
                        if (!deleted.has(i / 3)) newIndices.push(origIndex.getX(i), origIndex.getX(i+1), origIndex.getX(i+2));
                    }
                    origGeom.setIndex(newIndices);
                    if(child.geometry !== child.userData.originalGeometry) child.geometry.dispose();
                    child.geometry = origGeom;
                }
            });
            updateLiveStats();
        }

        simplifySlider.addEventListener('input', (e) => {
            const val = parseInt(e.target.value);
            targetVal.textContent = val.toLocaleString();
        });

        btnApplyDecimate.addEventListener('click', () => {
            if (!currentModel) return;
            const targetTris = parseInt(simplifySlider.value);
            
            showLoading(true, "DECIMATING MESH...");

            setTimeout(() => {
                if (targetTris >= baseStats.triangles || document.getElementById('target-type').value === 'full') {
                    resetGeometryForErasing(); 
                } else {
                    const reductionRatio = targetTris / baseStats.triangles;
                    const modifier = new SimplifyModifier();

                    currentModel.traverse((child) => {
                        if (child.isMesh && child.userData.originalGeometry && !child.userData.isHidden) {
                            try {
                                const cleanGeom = getCleanBaseGeometry(child);
                                const currentVertices = cleanGeom.attributes.position.count;
                                const oldGeom = child.geometry;
                                const targetMeshVerts = Math.max(3, Math.floor(currentVertices * reductionRatio));
                                const countToRemove = currentVertices - targetMeshVerts;

                                if (countToRemove > 0) {
                                    const simplifiedGeom = modifier.modify(cleanGeom, countToRemove);
                                    simplifiedGeom.computeVertexNormals();
                                    child.geometry = simplifiedGeom;
                                } else {
                                    child.geometry = cleanGeom;
                                }
                                
                                if (oldGeom !== child.userData.originalGeometry) oldGeom.dispose();
                            } catch(e) { console.warn("Topology too complex/broken for decimation on part", child.name); }
                        }
                    });
                }
                updateLiveStats();
                showLoading(false);
            }, 50);
        });

        function showLoading(show, text="PROCESSING...") {
            document.getElementById('loading-text').textContent = text;
            if (show) document.getElementById('loading-overlay').classList.remove('hidden');
            else document.getElementById('loading-overlay').classList.add('hidden');
        }

        // --- Export LFS .OBJ ---
        btnConvert.addEventListener('click', () => executeExport(false));
        btnConvertSel.addEventListener('click', () => executeExport(true));

        function executeExport(onlySelected) {
            if (!currentModel) return;
            
            const target = targetTypeSelect.value;
            if (!onlySelected && target !== 'full' && (modelStats.vertices > LIMITS[target].verts || modelStats.triangles > LIMITS[target].polys)) {
                const confirmExport = confirm(`Atenção: A cena toda excede os limites de poli para o modo ${target}. LFS pode falhar a conversão. Quer exportar mesmo assim?`);
                if (!confirmExport) return;
            }

            showLoading(true, "GENERATING LFS .OBJ...");
            setTimeout(() => {
                const objBlob = generateOBJBlob(currentModel, onlySelected);
                downloadBlob(objBlob, `${originalFileName}${onlySelected ? '_selected' : ''}.obj`);
                showLoading(false);
            }, 100);
        }

        function generateOBJBlob(modelScene, onlySelected) {
            let output = "# Exported for Live for Speed Editor\n# Coordinate System: Y forward, Z up\n\n";
            let globalVertexOffset = 1;

            modelContainer.updateMatrixWorld(true);
            
            modelScene.traverse((child) => {
                if (child.isMesh && child.geometry && child.geometry.index && !child.userData.isHidden) {
                    
                    if (onlySelected && (!child.userData.selectedFaces || child.userData.selectedFaces.size === 0)) {
                        return; // Pula se exportação for seletiva e a peça não tiver nada selecionado
                    }

                    const geom = child.geometry;
                    const pos = geom.attributes.position;
                    const norm = geom.attributes.normal;
                    const index = geom.index;
                    
                    const usedIndices = new Set();
                    
                    if(onlySelected) {
                        // Gather vertices just for selected faces
                        for (let i = 0; i < index.count; i += 3) {
                            if (child.userData.selectedFaces.has(i / 3)) {
                                usedIndices.add(index.getX(i));
                                usedIndices.add(index.getX(i+1));
                                usedIndices.add(index.getX(i+2));
                            }
                        }
                    } else {
                        // Gather all vertices
                        for (let i = 0; i < index.count; i++) usedIndices.add(index.getX(i));
                    }

                    if(usedIndices.size === 0) return;

                    output += `o ${child.name || 'Mesh'}\n`;
                    const matrix = child.matrixWorld;
                    const normalMatrix = new THREE.Matrix3().getNormalMatrix(matrix);
                    
                    const indexMap = new Map();
                    let localNewIndex = 0;
                    const v = new THREE.Vector3(), n = new THREE.Vector3();
                    
                    for (let i = 0; i < pos.count; i++) {
                        if (usedIndices.has(i)) {
                            indexMap.set(i, globalVertexOffset + localNewIndex);
                            localNewIndex++;
                            v.fromBufferAttribute(pos, i).applyMatrix4(matrix); 
                            output += `v ${v.x.toFixed(6)} ${-v.z.toFixed(6)} ${v.y.toFixed(6)}\n`;
                        }
                    }
                    
                    if (norm) {
                        for (let i = 0; i < pos.count; i++) {
                            if (usedIndices.has(i)) {
                                n.fromBufferAttribute(norm, i).applyMatrix3(normalMatrix).normalize();
                                output += `vn ${n.x.toFixed(6)} ${-n.z.toFixed(6)} ${n.y.toFixed(6)}\n`;
                            }
                        }
                    }
                    
                    for (let i = 0; i < index.count; i += 3) {
                        const faceIdx = i / 3;
                        if (onlySelected && !child.userData.selectedFaces.has(faceIdx)) continue;
                        
                        const a = indexMap.get(index.getX(i)), b = indexMap.get(index.getX(i+1)), c = indexMap.get(index.getX(i+2));
                        if (norm) output += `f ${a}//${a} ${b}//${b} ${c}//${c}\n`;
                        else output += `f ${a} ${b} ${c}\n`;
                    }
                    globalVertexOffset += usedIndices.size;
                    output += '\n';
                }
            });
            return new Blob([output], { type: 'text/plain' });
        }

        function downloadBlob(blob, filename) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);
        }

        initThreeJS();

    </script>
</body>
</html>
